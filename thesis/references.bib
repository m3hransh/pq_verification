@book{okasaki,
  title = {Purely {{Functional Data Structures}}},
  author = {Okasaki, Chris},
  date = {1998},
  publisher = {Cambridge University Press},
  location = {Cambridge},
  doi = {10.1017/CBO9780511530104},
  urldate = {2025-04-06},
  abstract = {Most books on data structures assume an imperative language like C
              or C++. However, data structures for these languages do not always
              translate well to functional languages such as Standard ML, Haskell
              , or Scheme. This book describes data structures from the point of
              view of functional languages, with examples, and presents design
              techniques so that programmers can develop their own functional
              data structures. It includes both classical data structures, such
              as red-black trees and binomial queues, and a host of new data
              structures developed exclusively for functional languages. All
              source code is given in Standard ML and Haskell, and most of the
              programs can easily be adapted to other functional languages. This
              handy reference for professional programmers working with
              functional languages can also be used as a tutorial or for
              self-study.},
  isbn = {978-0-521-63124-2},
}

@inproceedings{rondonLiquidTypes2008,
  title = {Liquid Types},
  booktitle = {Proceedings of the 29th {{ACM SIGPLAN Conference}} on {{
               Programming Language Design}} and {{Implementation}}},
  author = {Rondon, Patrick M. and Kawaguci, Ming and Jhala, Ranjit},
  date = {2008-06-07},
  series = {{{PLDI}} '08},
  pages = {159--169},
  publisher = {Association for Computing Machinery},
  location = {New York, NY, USA},
  doi = {10.1145/1375581.1375602},
  url = {https://dl.acm.org/doi/10.1145/1375581.1375602},
  urldate = {2025-03-03},
  abstract = {We present Logically Qualified Data Types, abbreviated to Liquid
              Types, a system that combines Hindley-Milner type inference with
              Predicate Abstraction to automatically infer dependent types
              precise enough to prove a variety of safety properties. Liquid
              types allow programmers to reap many of the benefits of dependent
              types, namely static verification of critical properties and the
              elimination of expensive run-time checks, without the heavy price
              of manual annotation. We have implemented liquid type inference in
              DSOLVE, which takes as input an OCAML program and a set of logical
              qualifiers and infers dependent types for the expressions in the
              OCAML program. To demonstrate the utility of our approach, we
              describe experiments using DSOLVE to statically verify the safety
              of array accesses on a set of OCAML benchmarks that were previously
              annotated with dependent types as part of the DML project. We show
              that when used in conjunction with a fixed set of array bounds
              checking qualifiers, DSOLVE reduces the amount of manual annotation
              required for proving safety from 31\% of program text to under 1\%.
              },
  isbn = {978-1-59593-860-2},
}

@article{vazou2018,
  title = {Refinement Reflection: Complete Verification with {{SMT}}},
  shorttitle = {Refinement Reflection},
  author = {Vazou, Niki and Tondwalkar, Anish and Choudhury, Vikraman and Scott,
            Ryan G. and Newton, Ryan R. and Wadler, Philip and Jhala, Ranjit},
  date = {2018-01},
  journaltitle = {Proceedings of the ACM on Programming Languages},
  shortjournal = {Proc. ACM Program. Lang.},
  volume = {2},
  pages = {1--31},
  issn = {2475-1421},
  doi = {10.1145/3158141},
  url = {https://dl.acm.org/doi/10.1145/3158141},
  urldate = {2024-12-15},
  abstract = {We introduce Refinement Reflection , a new framework for building
              SMT-based deductive verifiers. The key idea is to reflect the code
              implementing a user-defined function into the function’s (output)
              refinement type. As a consequence, at uses of the function, the
              function definition is instantiated in the SMT logic in a precise
              fashion that permits decidable verification. Reflection allows the
              user to write equational proofs of programs just by writing other
              programs using pattern-matching and recursion to perform
              case-splitting and induction. Thus, via the propositions-as-types
              principle, we show that reflection permits the specification of
              arbitrary functional correctness properties. Finally, we introduce
              a proof-search algorithm called Proof by Logical Evaluation that
              uses techniques from model checking and abstract interpretation, to
              completely automate equational reasoning. We have implemented
              reflection in Liquid Haskell and used it to verify that the widely
              used instances of the Monoid, Applicative, Functor, and Monad
              typeclasses actually satisfy key algebraic laws required to make
              the clients safe, and have used reflection to build the first
              library that actually verifies assumptions about associativity and
              ordering that are crucial for safe deterministic parallelism.},
  issue = {POPL},
  langid = {english},
}

@book{knuth1973taocp3,
  author = {Donald E. Knuth},
  title = {The Art of Computer Programming, Volume 3: Sorting and Searching},
  publisher = {Addison-Wesley},
  year = {1973},
  edition = {1st},
  address = {Reading, Massachusetts},
  isbn = {0-201-03803-X},
}

@techreport{crane1972,
  author = {Clark Crane},
  title = {Linear Lists and Priority Queues as Balanced Binary Trees},
  institution = {Carnegie Mellon University},
  year = {1972},
  type = {Technical Report},
}

@article{vazou2014,
  title = {Refinement Types For Haskell},
  volume = {49},
  issn = {978-1-4503-2873-9},
  doi = {10.1145/2628136.2628161},
  abstract = {{SMT}-based checking of refinement types for call-by-value
              languages is a well-studied subject. Unfortunately, the classical
              translation of refinement types to verification conditions is
              unsound under lazy evaluation. When checking an expression, such
              systems implicitly assume that all the free variables in the
              expression are bound to values. This property is trivially
              guaranteed by eager, but does not hold under lazy, evaluation. Thus
              , to be sound and precise, a refinement type system for Haskell and
              the corresponding verification conditions must take into account
              which subset of binders actually reduces to values. We present a
              stratified type system that labels binders as potentially diverging
              or not, and that (circularly) uses refinement types to verify the
              labeling. We have implemented our system in {LIQUIDHASKELL} and
              present an experimental evaluation of our approach on more than 10,
              000 lines of widely used Haskell libraries. We show that {
              LIQUIDHASKELL} is able to prove 96\% of all recursive functions
              terminating, while requiring a modest 1.7 lines of
              termination-annotations per 100 lines of code.},
  journal = {{ACM} {SIGPLAN} Notices},
  shortjournal = {{ACM} {SIGPLAN} Notices},
  author = {Vazou, Niki and Seidel, Eric and Jhala, Ranjit and Vytiniotis,
            Dimitrios and Peyton Jones, Simon},
  year = {2014},
  date = {2014-08-19},
}

@misc{niki_lecture_2024,
  title = {{Programming with Refinement Types} Lecture},
  author = {Vazou, Niki},
  url = {https://nikivazou.github.io/lh-course},
  date = {2024-03-15},
}

@article{pena2017,
  title = {An {{Introduction}} to {{Liquid Haskell}}},
  author = {Peña, Ricardo},
  date = {2017-01-12},
  journaltitle = {Electronic Proceedings in Theoretical Computer Science},
  shortjournal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {237},
  doi = {10.4204/EPTCS.237.5},
  abstract = {This paper is a tutorial introducing the underlying technology and
              the use of the tool Liquid Haskell, a type-checker for the
              functional language Haskell that can help programmers to verify
              non-trivial properties of their programs with a low effort. The
              first sections introduce the technology of Liquid Types by
              explaining its principles and summarizing how its type inference
              algorithm manages to prove properties. The remaining sections
              present a selection of Haskell examples and show the kind of
              properties that can be proved with the system.},
  file = {/home/mehran/Zotero/storage/SPM6IEBU/Peña - 2017 - An Introduction to
          Liquid Haskell.pdf},
}


@misc{jhala2020,
  title = {Programming {With} {Refinement} {Types}},
  language = {en},
  url = {https://ucsd-progsys.github.io/liquidhaskell-tutorial/},
  author = {Jhala, Ranjit and Seidel, Eric and Vazou, Niki},
  month = jul,
  year = {2020},
  file = {PDF:/home/mehran/Zotero/storage/35GVUEX9/Jhala et al. - Programming
          With Refinement Types.pdf:application/pdf},
}

@article{wadler_propositions_2015,
  title = {Propositions as types},
  volume = {58},
  issn = {0001-0782},
  url = {https://dl.acm.org/doi/10.1145/2699407},
  doi = {10.1145/2699407},
  abstract = {Connecting mathematical logic and computation, it ensures that
              some aspects of programming are absolute.},
  pages = {75--84},
  number = {12},
  journal = {Commun. {ACM}},
  author = {Wadler, Philip},
  urldate = {2025-02-03},
  date = {2015-11-23},
  year = {2015},
  file = {Full Text PDF:/home/mehran/Zotero/storage/PHW6DIQS/Wadler - 2015 -
          Propositions as types.pdf:application/pdf},
}
