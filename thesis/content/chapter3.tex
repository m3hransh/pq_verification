\chapter{Priority Queue Implementations}
\label{ch:impl}
\section{Specification of Priority Queue Interface}

Priority queues are multisets with an associated priority for each element, allowing efficient retrieval of the element with the highest (or lowest) priority.
To avoid confusion with FIFO queues, we will refer to them as "heaps" throughout this thesis.

Priority queues are widely used in computer science and engineering.
They play a central role in \emph{operating systems} for task scheduling, in \emph{graph algorithms} such as Dijkstra’s shortest path \cite{Dijkstra59} and Prim’s minimum spanning tree \cite{Prim57}, and in \emph{discrete event simulation},
where events are processed in order of occurrence time.
Other applications include data compression (e.g., Huffman coding \cite{Huffman52}) and networking (packet scheduling).

Typical operations include:
\begin{itemize}
	\item \textbf{insert}: Add a new element with a given priority.
	\item \textbf{merge}: Combine two heaps into one.
	\item \textbf{findMin}: Retrieve the element with the minimum key (in the min-heap variant).
	\item \textbf{splitMin}: Return a pair consisting of the minimum key and a heap with that minimum element removed.
  \item \textbf{empty and isEmpty}: Create an empty heap and check if a heap is empty.
\end{itemize}

Below is the specification of the priority queue interface, defined as a Haskell type class.
\texttt{MinView} is a utility type to represent the result of the \texttt{splitMin} operation,
which returns the minimum element and the remaining heap.

\begin{code}[caption={Leftist Heap Implementation in Haskell}, label={lst:pq}]
data MinView q a =
  EmptyView | Min {minValue :: a, restHeap :: q a}
  deriving (Show, Eq)

class PriorityQueue pq where
  insert :: (Ord a) => a -> pq a -> pq a
  merge :: (Ord a) => pq a -> pq a -> pq a
  findMin :: (Ord a) => pq a -> Maybe a
  splitMin :: (Ord a) => pq a -> MinView pq a
  empty :: (Ord a) => pq a
  isEmpty :: (Ord a) => pq a -> Bool
\end{code}


In this thesis, we focus on the \emph{min-priority queue}, where elements with lower keys are considered higher priority.
We will study and verify functional implementations of \emph{Leftist Heaps} and some parts of \emph{Binomial Heaps}.

% , \emph{Binary Heaps}, and an optional third variant such as Skew Heaps or Binomial Heaps %TODO: Might not be covered
% Each implementation offers different trade-offs in terms of complexity, ease of reasoning, and verification effort.

\section{Leftist Heap Implementation}

Leftist heaps, introduced by Crane~\cite{crane1972} and discussed extensively by
Knuth~\cite{knuth1973taocp3}, are a variant of binary heaps designed to support
efficient merging. They are defined by two key invariants:

\begin{itemize}
	\item \textbf{Heap Property} – For every node, the stored key is less than or equal
	      to the keys of its children. This ensures that the minimum element is always
	      found at the root.

	\item \textbf{Leftist Property} – For every node, the rank (also called the
	      \emph{right spine length}, i.e., the length of the rightmost path from the node in question to an empty node)
	      of the left child is greater than or equal to that of the right child.
	      This property ensures that the right spine of the heap is kept as short as
	      possible, which in turn guarantees logarithmic time complexity for merging
	      operations\cite{okasaki}.
\end{itemize}
\input{figures/leftistHeap.tex}
We represent leftist heaps using a recursive algebraic data type in Haskell, as described by Okasaki~\cite{okasaki}:
\begin{code}[caption={Leftist Heap data type}, label={lst:leftist}]
data LeftistHeap a
= EmptyHeap
| HeapNode
  { value :: a
  , left  :: LeftistHeap a
  , right :: LeftistHeap a
  , rank  :: Int
  }
\end{code}

Each node contains a value, its left subtree, right subtree, and its rank.

The merge operation merges the right subtree of the heap with the smaller root value with the other heap. After merging,
it adjusts the rank by swapping the left and right subtrees if necessary using the function \texttt{makeHeapNode}.
\begin{code}[caption={Leftist Heap merge}, label={lst:leftist-merge}]
heapMerge :: (Ord a) => LeftistHeap a -> LeftistHeap a -> LeftistHeap a
heapMerge EmptyHeap EmptyHeap = EmptyHeap
heapMerge EmptyHeap h2@(HeapNode _ _ _ _) = h2
heapMerge h1@(HeapNode _ _ _ _) EmptyHeap = h1
heapMerge h1@(HeapNode x1 l1 r1 _) h2@(HeapNode x2 l2 r2 _)
| x1 <= x2 = makeHeapNode x1 l1 (heapMerge r1 h2)
| otherwise = makeHeapNode x2 l2 (heapMerge h1 r2)
\end{code}
Because the the right spine is kept short by the leftist property and at most is logarithmic, the merge operation runs in \(O(\log n)\) time.
\begin{code}[caption={Leftist Heap helper functions}, label={lst:leftist-helpers}]
makeHeapNode :: a -> LeftistHeap a -> LeftistHeap a -> LeftistHeap a
makeHeapNode x h1 h2
| rrank h1 >= rrank h2 = HeapNode x h1 h2 (rrank h2 + 1)
| otherwise = HeapNode x h2 h1 (rrank h1 + 1)
\end{code}

Other functions are straightforward to implement.
\begin{code}[]
heapEmpty :: (Ord a) => LeftistHeap a
heapEmpty = EmptyHeap

heapFindMin :: (Ord a) => LeftistHeap a -> Maybe a
heapFindMin EmptyHeap = Nothing
heapFindMin (HeapNode x _ _ _) = Just x

heapIsEmpty :: (Ord a) => LeftistHeap a -> Bool
heapIsEmpty EmptyHeap = True
heapIsEmpty _ = False

heapInsert :: (Ord a) => a -> LeftistHeap a -> LeftistHeap a
heapInsert x h = heapMerge (HeapNode x EmptyHeap EmptyHeap 1) h

heapSplit :: (Ord a) => LeftistHeap a -> MinView LeftistHeap a
heapSplit EmptyHeap = EmptyView
heapSplit (HeapNode x l r _) = Min x (heapMerge l r)
\end{code}

In the chapter \ref{ch:verification}, we will verify that these implementations satisfy the priority queue interface and maintain the leftist heap invariants.

\section{Binomial Heap Implementation}
\label{sec:binomial-impl}

For our verified implementation of binomial heaps, we follow the approach of \emph{binary binomial heaps} as described by Hinze~\cite{Hinze99}. This approach represents a heap as a list of trees, analogous to a binary number, which allows for a clean and efficient implementation of the merge operation.

Instead of classical binomial trees, this implementation uses \emph{pennants}\cite{sack1990}.
Pennants consist of a root node and a perfect binary tree.

\begin{code}[caption={Pennant Data Type}, label={lst:pennant-type}]
data BinTree a
  = Empty
  | Bin { value :: a
        , left :: BinTree a
        , right :: BinTree a
        , height :: Int 
        }

data Pennant a = P { root :: a
                   , pheight :: Int
                   , bin :: (BinTree a)
                   }
\end{code}

A pennant's \texttt{pheight} corresponds to its height \(h\).
The \texttt{root} holds the minimum element, and \texttt{bin} is the internal \texttt{BinTree} structure containing the other \(2^h - 1\) elements.


There are three invariants that pennants must satisfy:
\begin{itemize}
    \item {\textbf{Minimum Property}: The root of the pennant is less than or equal to all other elements in the pennant.}
    \item {\textbf{Left-ordering Property}: For every node in the internal binary tree, the value of the left child is less than or equal to the value of the right child.}
    \item {\textbf{Perfect Binary Tree Property}: The internal binary tree is a perfect binary tree, meaning all internal nodes have two children and all leaves are at the same level.}
\end{itemize}

\input{figures/binomial.tex}
The primary operation on pennants is \texttt{link}, which combines two pennants of equal height~$h$ into a single pennant of height~$h+1$.
The root of the resulting pennant is less than or equal to the roots of the two original pennants.

\begin{code}[caption={Linking two Pennants}, label={lst:pennant-link}]
link :: (Ord a) => Pennant a -> Pennant a -> Pennant a
link p1@(P r1 h t1) p2@(P r2 _ t2)
  | r1 <= r2  = P r1 (h + 1) (Bin r2 t2 t1 h)
  | otherwise = P r2 (h + 1) (Bin r1 t1 t2 h)
\end{code}

A binomial heap is then represented as a list of "bits", where each bit can be either \texttt{Zero} or \texttt{One}.
A \texttt{One} bit at position (\texttt{rank}) \(i\)  signifies the presence of a pennant of height \(i\).

\begin{code}[caption={Binomial Heap Representation}, label={lst:binary-binomial-heap}]
data BinomialBit a =
      Zero { rank :: Int }
    | One  { rank :: Int, pennant :: Pennant a }

type BinomialHeap a = [BinomialBit a]
\end{code}

Merging two binomial heaps is analogous to adding two binary numbers.
The addition is performed by a ripple-carry adder that processes the lists of bits.
For instance, adding two \texttt{One} bits of the same rank involves linking their pennants to form a carry bit of the next higher rank.

Following the ripple-carry adder approach, we define a \texttt{halfAdder} function that takes two bits and produces a sum bit and a carry bit.

\begin{code}[caption={Half Adder for Binomial Bits}, label={lst:bit-half-adder}]
bHalfAdder :: (Ord a) => BinomialBit a
                      -> BinomialBit a
                      -> (BinomialBit a, BinomialBit a)
bHalfAdder b1 b2 = (bSum b1 b2, bCarry b1 b2)
\end{code}

Additionally, we define a \texttt{fullAdder} function that takes two bits and an incoming carry bit, producing a sum bit and an outgoing carry bit.
\begin{code}[caption={Full Adder for Binomial Bits}, label={lst:bit-adder}]
bFullAdder :: (Ord a) => BinomialBit a
                      -> BinomialBit a
                      -> BinomialBit a
                      -> (BinomialBit a, BinomialBit a)
bFullAdder b1 b2 cin = 
  let (s, c1) = bHalfAdder b1 b2
      (s', c2) = bHalfAdder s c
   in (s', bSum c1 c2)
\end{code}

The bSum and bCarry functions handle the logic for combining bits of the same rank according to the rules of binary addition.
\begin{code}[caption={bSum and bCarry Functions}, label={lst:bit-sum-carry}]
bSum :: (Ord a) => BinomialBit a
                -> BinomialBit a
                -> BinomialBit a
bSum (Zero r) (Zero _) = Zero r
bSum (Zero r) (One _ p) = One r p
bSum (One _ p) (Zero r) = One r p
bSum (One r1 p1) (One r2 p2) = Zero r1
bCarry :: (Ord a) => BinomialBit a
                  -> BinomialBit a
                  -> BinomialBit a
bCarry (Zero r1) (Zero r2) = Zero (r1 + 1)
bCarry (Zero r1) (One _ p2) = Zero (r1 + 1)
bCarry (One _ p1) (Zero r2) = Zero (r2 + 1)
bCarry (One r1 p1) (One _ p2) = One (r1 + 1) (link p1 p2)

\end{code}

Finally, we can implement adding of two binomial heaps using the full adder logic.
\begin{code}[caption={Merging Two Binomial Heaps}, label={lst:heap-merge}]
add :: (Ord a) => BinomialHeap a
               -> BinomialHeap a
               -> BinomialHeap a
add xs ys = addWithCarry xs ys (Zero 0)

addWithCarry :: (Ord a) => BinomialHeap a
                        -> BinomialHeap a
                        -> BinomialBit a
                        -> BinomialHeap a
addWithCarry Nil Nil c
  | c == (Zero 0) = Nil
  | otherwise = Cons c Nil
addWithCarry (Cons x xs) Nil (Zero r) = Cons x xs
addWithCarry (Cons x xs) Nil c@(One r _) =
  let z = Zero (rank x)
      (s, c') = bFullAdder x z c
   in 
    Cons s (addWithCarry xs Nil c')
addWithCarry Nil (Cons y ys) c =
  let z = Zero (rank y)
      (s, c') = bFullAdder z y c
    in
      Cons s (addWithCarry Nil ys c')
addWithCarry (Cons x xs) (Cons y ys) c =
  let (s, c') = bFullAdder x y c
  in Cons s (addWithCarry xs ys c')

\end{code}
The main priority queue operations are implemented as follows:
\begin{itemize}
    \item {\textbf{merge}: Two heaps are merged by adding their corresponding lists of bits using the full adder logic.
This takes \(O(\log n)\) time.
\begin{code}[caption={Merging Two Binomial Heaps}, label={lst:heap-merge-main}]
merge :: (Ord a) => BinomialHeap a 
                 -> BinomialHeap a 
                 -> BinomialHeap a
merge h1 h2 = add h1 h2
\end{code}
}
    \item {\textbf{insert}: A new element is treated as a pennant of rank 0.
It is "added" to the heap, which may cause a series of carries.
This is an \(O(\log n)\) operation, with amortized \(O(1)\) complexity.
\begin{code}[caption={Inserting an Element into Binomial Heap}, label={lst:heap-insert}]
insert :: (Ord a) => a 
                  -> BinomialHeap a 
                  -> BinomialHeap a
insert x heap = merge [One 0 (P x 0 (Empty))] heap
\end{code}
}
    \item {\textbf{findMin}: This requires finding the minimum among the roots of all pennants in the heap.
Since there are at most \(\log n\) pennants, this takes \(O(\log n)\) time. The implementation recursively scans through the list of bits, skipping \texttt{Zero} bits and comparing the roots of \texttt{One} bits to find the minimum.}
\begin{code}[caption={Finding Minimum in Binomial Heap}, label={lst:heap-find}]
findMin :: (Ord a) => BinomialHeap a -> Maybe a
findMin Nil = Nothing
findMin (Cons (Zero _) bs) = findMin bs
findMin (Cons (One _ (P r _ _)) Nil) = Just r
findMin (Cons (One _ (P r _ _)) bs) = 
  case findMin bs of
    Nothing -> Just r
    Just r' -> Just (min r r')
\end{code}

    \item {\textbf{extractMin}: This helper function scans through the heap to find the pennant with the minimum root value, removes it from the heap, and returns both the pennant and the remaining heap. It recursively compares roots and maintains heap structure by preserving \texttt{Zero} bits and selecting the pennant with the smaller root.}
\begin{code}[caption={Extract Minimum Pennant from Binomial Heap}, label={lst:heap-extract}]
extractMin :: (Ord a) => BinomialHeap a 
                      -> (Pennant a, BinomialHeap a)
extractMin (Cons (Zero r) bs) = 
  let (p, bs') = extractMin bs
   in (p, Cons (Zero r) bs')
extractMin (Cons (One r p) Nil) = (p, Nil)
extractMin (Cons (One r p@(P m _ _)) bs) = 
  case extractMin bs of
    (p'@(P m' _ _), bs') 
      | m <= m' -> (p, Cons (Zero r) bs)
      | otherwise -> (p', Cons (One r p) bs')
\end{code}

    \item {\textbf{splitMin}: This is the most involved operation. First, \texttt{extractMin} finds and removes the pennant with the minimum root from the list of pennants.
Let's say it has rank \(k\). After removing the minimum root from this pennant, the remaining perfect binary tree of height \(k-1\) must be converted back into a binomial heap. This is accomplished by the \texttt{dismantle} function, which recursively splits the perfect binary tree into a list of pennants of ranks \(0\) to \(k-1\).
These pennants are then reversed and merged back with the remaining heap.
The overall complexity is \(O(\log n)\).}
\begin{code}[caption={Splitting Minimum from Binomial Heap}, label={lst:heap-split}]
splitMin :: (Ord a) => BinomialHeap a
                    -> MinView BinomialHeap a
splitMin Nil = EmptyView
splitMin heap = 
  let (minPennant, restHeap) = extractMin heap
      converted = case minPennant of
        P _ 0 _ -> restHeap
        P _ _ bt -> 
          let dismantled = reverseToBinomialHeap (dismantle bt)
           in add restHeap dismantled
   in Min (root minPennant) converted
\end{code}

To facilitate the dismantling process, we introduce an auxiliary data structure \texttt{ReversedBinomialHeap}, which is a list of bits with \emph{decreasing} ranks (as opposed to the standard \texttt{BinomialHeap} where ranks increase).
\begin{code}[caption={Reversed Binomial Heap}, label={lst:reversed-heap}]
data ReversedBinomialHeap a =
    RNil
  | RCons { rhd :: BinomialBit a
          , rtl :: ReversedBinomialHeap a
          }
\end{code}

The \texttt{dismantle} function takes a perfect binary tree and converts it into a reversed list of pennants with decreasing ranks. For a tree of height \(h\), it produces pennants of ranks \(h, h-1, \ldots, 0\). The function works by recursively processing the right spine of the tree: at each node, it creates a pennant from the current node's value and left subtree, then recursively dismantles the right subtree.
\begin{code}[caption={Dismantle Perfect Binary Tree}, label={lst:dismantle}]
dismantle :: (Ord a) => BinTree a 
                     -> ReversedBinomialHeap a
dismantle Empty = RNil
dismantle (Bin m l r h) = case r of
  Empty -> RCons (One h (P m h l)) RNil
  Bin _ _ _ hr -> 
    let rest = dismantle r
     in RCons (One h (P m h l)) rest
\end{code}

The reversed heap is then converted back to a standard binomial heap using \texttt{reverseToBinomialHeap}, which reverses the list so that ranks increase from left to right. This conversion is necessary because the standard heap operations expect pennants ordered by increasing rank.
\end{itemize}

This representation of binomial heaps is both elegant and well-suited for formal verification, as we will discuss in Chapter \ref{ch:verification}.
Rather than verifying every operation, we concentrate on the main operations, which serves as the fundamental building block from which other operations can be derived.

