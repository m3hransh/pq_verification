\chapter{Verification in LiquidHaskell}
\label{ch:verification}
This chapter verifies our priority queue implementations using LiquidHaskell.
We first factor out the common logical infrastructure used by both heaps
(\S\ref{sec:shared-infra}), then present the leftist-heap development
(\S\ref{sec:verify-leftist}), and finally \emph{only} those parts of the
binomial heap for which we currently have mechanized proofs (\S\ref{sec:verify-binomial}).
Throughout, we refer back to Chapter~\ref{ch:lh} for the LiquidHaskell
features we rely on (reflection, measures, PLE, and termination).

\section{Shared Logical Infrastructure}
\label{sec:shared-infra}

We reuse LiquidHaskell features introduced in Chapter~\ref{ch:lh}:
\begin{itemize}
  \item \textbf{Measures and refined data types} (\S\ref{sec:reflection}--\ref{sec:lh-refined-datatypes})
        to expose structural invariants to the refinement logic.
  \item \textbf{Reflection and equational reasoning} (\S\ref{sec:reflection}, \S\ref{sec:proofs})
        for unfolding definitions during proofs.
  \item \textbf{Proof by Logical Evaluation (PLE)} (\S\ref{sec:lh-ple}) to automate unfolding-driven proofs.
  \item \textbf{Termination metrics} (\S\ref{sec:termination}) using size/height and lexicographic tuples.
\end{itemize}

We also standardize the following predicate, reused by both heaps:
\[
\mathsf{isLowerBound}\ v\ t \ \triangleq\ v \le \text{every element of } t,
\]
so that lower-bound obligations can be phrased uniformly for tree- and heap-shaped structures.

\section{Verification of Leftist Heaps}
\label{sec:verify-leftist}
The cornerstone of the verification is the refined data type for the leftist heap itself.
We encode the core invariants of the data structure directly into its type definition.
In LiquidHaskell notation, the refined \texttt{LeftistHeap} type is defined as follows:

\begin{code}
data LeftistHeap a = EmptyHeap
      | HeapNode { value :: a
         , left  :: LeftistHeapBound a value
         , right :: {v : LeftistHeapBound a value  | rrank v <= rrank left }
         , rank :: {r : Nat | r == 1 + rrank right}
        }
\end{code}

This refined definition enforces three key invariants:
\begin{enumerate}
    \item \textbf{Heap Property:} The value at any node is the minimum in its subtree.
    This is captured by the \texttt{LeftistHeapBound a X} refinement type on the \texttt{left} and \texttt{right} children.
    \texttt{isLowerBound} is a recursively defined predicate that checks if a given value is less than or equal to all elements in a heap.
    \begin{code}
{-@ type LeftistHeapBound a X = { h : LeftistHeap a | isLowerBound X h} @-}
{-@ reflect isLowerBound @-} 
isLowerBound :: (Ord a) => a -> LeftistHeap a -> Bool
isLowerBound _ EmptyHeap = True
isLowerBound v (HeapNode x l r _) = 
    v <= x && isLowerBound v l && isLowerBound v r
    \end{code}
    
    \item \textbf{Leftist Property:} For any node, the rank of its right child is less than or equal to the rank of its left child. This is expressed by \texttt{rrank v <= rrank left}. This property is what ensures that the right spine of the heap is short, leading to logarithmic time complexity for merge operations.
    
    \item \textbf{Rank Property:} The rank of a node is defined as one plus the rank of its right child. This is specified by \texttt{rank :: \{r : Nat | r == 1 + rrank right\}}. The rank of an \texttt{EmptyHeap} is 0.
\end{enumerate}

By embedding these invariants directly into the type, \texttt{LiquidHaskell}'s verifier will ensure that any function constructing or modifying a \texttt{LeftistHeap} respects them.

Following the interface defined in Chapter~\ref{lst:pq}, we refine the types of the heap operations to ensure they maintain the invariants of the leftist heap.
Unfortunately, due to limitations in \texttt{LiquidHaskell}'s current support for type classes,
we cannot directly define the invariants for the \texttt{PriorityQueue} type class.
Instead, we provide refined type signatures for each operation individually.
To express these invariants and reason about the behavior of our functions, we use several features of \texttt{LiquidHaskell}.

\textbf{Measures} (see Section~\ref{sec:reflection}) are functions from Haskell's term-level to the refinement logic's domain. We define several measures:
\begin{itemize}
	\item \texttt{size}: Computes the total number of nodes in the heap, useful for termination metrics (see Section~\ref{sec:termination}).
	\item \texttt{rrank}: Returns the rank of a heap, which is crucial for the leftist property.
	\item \texttt{bag}: Converts the heap into a multiset (or bag) of its elements. This is invaluable for proving that operations like \texttt{heapMerge} do not lose or duplicate elements.
\end{itemize}

\textbf{Reflected Functions} (see Section~\ref{sec:reflection}) allow us to use standard Haskell functions within the refinement logic. We use this for \texttt{isLowerBound}, \texttt{heapMerge}, and \texttt{makeHeapNode}.
This allows us to reason about their behavior during verification.


In the following sections,
we present the refined type signatures and implementations of the key heap operations,
along with explanations of how they maintain the invariants of the leftist heap.
\subsection{Heap isEmpty}
This function checks if the heap is empty.
There is no invariate to maintain here, but we define a measure to help with other proofs.
\begin{code}
{-@ measure heapIsEmpty @-}
{-@ heapIsEmpty :: LeftistHeap a -> Bool @-}
heapIsEmpty :: (Ord a) => LeftistHeap a -> Bool
heapIsEmpty EmptyHeap = True
heapIsEmpty _ = False
\end{code}
\subsection{Heap findMin}
To retrieve the minimum element from a non-empty heap, we define \texttt{heapFindMin}.
We restrict its input to non-empty heaps and specify that the returned value is a lower bound for the heap.
As per the heap property, the minimum element is always at the root of the heap.
This can directly be extracted from the \texttt{HeapNode} and \texttt{LiquidHaskell} can verify that this value is indeed a lower bound for the entire heap.
\begin{code}
{-@ heapFindMin :: h : {h : LeftistHeap a | not (heapIsEmpty h)} 
      -> {v : a | isLowerBound v h} @-}
heapFindMin :: (Ord a) => LeftistHeap a -> a
heapFindMin (HeapNode x _ _ _) = x
\end{code}

\subsection{Heap Merge}
The most critical operation for a leftist heap is \texttt{heapMerge}. 
Its correctness is fundamental to the correctness of \texttt{insert} and \texttt{deleteMin}.
The type signature for \texttt{heapMerge} specifies its behavior:
\begin{code}
heapMerge :: h1 : LeftistHeap a 
      -> h2: LeftistHeap a 
      -> {h : LeftistHeap a | (HeapMergeMin h1 h2 h) 
                           && (BagUnion h1 h2 h)}
      / [size h1, size h2, 0]
\end{code}
This signature guarantees that merging two valid leftist heaps results in a new valid leftist heap,
that the heap property is maintained, and that the set of elements is preserved.

To express these properties, we have defined two predicates:
\begin{code}
predicate HeapMergeMin H1 H2 H = 
  ((not (heapIsEmpty H1) && not (heapIsEmpty H2)) => 
  isLowerBound (min (heapFindMin H1) (heapFindMin H2)) H )
predicate BagUnion H1 H2 H = 
  (bag H == B.union (bag H1) (bag H2))
\end{code}

\texttt{HeapMergeMin} asserts that the resulting heap \texttt{H} respects the heap property relative to the minimum elements of the input heaps \texttt{H1} and \texttt{H2}.
\texttt{BagUnion} asserts that the elements in the merged heap are the union of the elements from the input heaps.

The implementation of \texttt{heapMerge} involves a recursive call.
To help the SMT solver prove that the invariants hold through this recursion,
we provide helper lemmas. For example, in the case where \texttt{x1 <= x2},
we merge the right child of the first heap (\texttt{r1}) with the second heap (\texttt{h2}).
We must provide the proof for \texttt{LiquidHaskell} that the root value \texttt{x1} is a lower bound for this newly merged heap.

\begin{code}
heapMerge h1@(HeapNode x1 l1 r1 _) h2@(HeapNode x2 l2 r2 _)
| x1 <= x2 = makeHeapNode x1 l1 ((heapMerge r1 h2) 
  `withProof` lemma_merge_case1 x1 x2 r1 h2)
| otherwise = makeHeapNode x2 l2 ((heapMerge h1 r2)
  `withProof` lemma_heapMerge_case2 x2 x1 r2 h1)
\end{code}

The \texttt{makeHeapNode} requires that its first argument is a lower bound for both its left and right children.
\begin{code}
makeHeapNode :: x : a
 -> {h : LeftistHeap a | isLowerBound x h}
 -> {h : LeftistHeap a | isLowerBound x h}
 -> {h : LeftistHeap a | isLowerBound x h}
\end{code}
In this context, \texttt{LiquidHaskell} can automatically infer that the root value (\texttt{x1} or \texttt{x2}) is a lower bound for the left child, since it is inherited from the parent heap.
However, for the right child, which is obtained from a recursive call to \texttt{heapMerge}, the proof must be supplied explicitly.
This proof obligation is discharged by auxiliary lemmas such as \texttt{lemma\_merge\_case1} and \texttt{lemma\_merge\_case2}.

The first lemma, \texttt{lemma\_merge\_case1}, handles the case where \texttt{x1 <= x2}.
It states that if \texttt{x1} is a lower bound for \texttt{r1} and \texttt{x2} is a lower bound for \texttt{h2}, then \texttt{x1} is also a lower bound for the result of merging \texttt{r1} and \texttt{h2}.
\begin{code}
lemma_merge_case1 :: x1 : a
  -> x2 : {a |  x1  <= x2}
  -> r1 : LeftistHeapBound a x1
  -> h2 : {LeftistHeapBound a x2 | not (heapIsEmpty h2)}
  -> {isLowerBound x1 (heapMerge r1 h2)}
  / [size r1, size h2, 1]
\end{code}

The proof proceeds by case analysis on the structure of \texttt{r1}.

\begin{code}
lemma_merge_case1 x1 x2 EmptyHeap h2 =
  isLowerBound x1 (heapMerge EmptyHeap h2)
    ? lemma_isLowerBound_transitive x1 x2 h2
    *** QED
lemma_merge_case1 x1 x2 r1@(HeapNode _ _ _ _) h2@(HeapNode _ _ _ _) =
  isLowerBound x1 (heapMerged)
    ? (lemma_isLowerBound_transitive x1 (min (heapFindMin r1) (heapFindMin h2)) (heapMerged))
    *** QED
 where
  heapMerged = heapMerge r1 h2
\end{code}

In the base case, when \texttt{r1} is empty, the merge simply returns \texttt{h2}.
Since \texttt{x1 <= x2} and \texttt{x2} is a lower bound for \texttt{h2}, it follows by transitivity that \texttt{x1} is also a lower bound for \texttt{h2}.
In the inductive case, both heaps are non-empty.
The result of \texttt{heapMerge r1 h2} again satisfies the lower-bound property, which is established through the transitive lemma below.


\subsubsection{Transitivity of Lower Bounds}
The lemma \texttt{lemma\_isLowerBound\_transitive} expresses the fundamental transitivity of the lower-bound relation across heaps.
It is used repeatedly throughout the verification of heap merge.
\begin{code}
{-@ lemma_isLowerBound_transitive :: x : a
      -> y : {v : a | x <= v}
      -> h : {h : LeftistHeap a | isLowerBound y h}
      -> {isLowerBound x h}
@-}
lemma_isLowerBound_transitive :: 
  (Ord a) => a
          -> a
          -> LeftistHeap a
          -> Proof
lemma_isLowerBound_transitive x y EmptyHeap = ()
lemma_isLowerBound_transitive x y (HeapNode z l r _) = lemma_isLowerBound_transitive x y l &&& lemma_isLowerBound_transitive x y r *** QED
\end{code}

This lemma formalizes the intuitive notion that if \texttt{x <= y} and \texttt{y} is a lower bound for all elements of a heap \texttt{h}, then \texttt{x} must also be a lower bound for \texttt{h}.
It is a small but essential proof component that supports most of the recursive heap reasoning.

\subsubsection{Symmetric Case}
A symmetric argument applies to the case where \texttt{x1 > x2}.
The second lemma, \texttt{lemma\_merge\_case2}, follows the same structure as \texttt{lemma\_merge\_case1} but exchanges the roles of the input heaps and their bounds.

\begin{code}
lemma_heapMerge_case2 :: x2 : a
  -> x1 : { v : a |  x2  <= v}
  -> r1 : {h : LeftistHeap a | isLowerBound x2 h}
  -> h2 : {h : LeftistHeap a | not (heapIsEmpty h) && isLowerBound x1 h}
  -> {isLowerBound x2 (heapMerge h2 r1)} 
  / [size h2, size r1, 1]
\end{code}
The reason we cannot simply reuse \texttt{lemma\_merge\_case1} is that the order of the arguments to \texttt{heapMerge} is swapped in this case.
And also the termination metric must reflect which arguments are reduced in the recursive call.
We discuss this in the next section.

\subsubsection{Dealing with Termination and Recursion}

\texttt{LiquidHaskell} must ensure that all recursive functions terminate. 
For \texttt{heapMerge}, we provide the following termination metric:

\begin{code}
/ [size h1, size h2, 0]
\end{code}

This specifies a lexicographically ordered tuple. 
\texttt{LiquidHaskell} verifies that for every recursive call within \texttt{heapMerge}, either the size of the first argument or the size of the second argument decreases. 
In our case, one of the heaps is replaced by its right child, which is strictly smaller, thereby decreasing the total size and ensuring termination. 
The trailing \texttt{0} acts as a tie-breaker: it allows us to extend the tuple later when reasoning about mutually recursive functions.

The lemma \texttt{lemma\_merge\_case1} is mutually recursive with \texttt{heapMerge}, which requires us to make explicit which arguments of \texttt{heapMerge} are reduced in the body of the function (for instance, \texttt{r1} compared to \texttt{h1}). 
To capture this, we use the following termination metric for \texttt{lemma\_merge\_case1}:

\begin{code}
/ [size r1, size h2, 1]
\end{code}

Here the final \texttt{1} ensures that 
\[
[size\ r1, size\ h2, 0] \;<\; [size\ r1, size\ h2, 1]
\]
in lexicographic order. 
This indicates that when \texttt{lemma\_merge\_case1} calls \texttt{heapMerge}, it is making progress towards termination.
In the same way, other supporting lemmas are also assigned termination metrics, which are automatically checked by the verifier.


Together, these lemmas ensure that \texttt{heapMerge} preserves the heap property and terminates correctly for all valid inputs.
They form the core of the mechanized proof that merging two leftist heaps yields a well-formed, correctly ordered, and element-preserving result.
\subsection{Heap Insert}
Heap insertion is implemented using heap merging.
The refined type signature for \texttt{heapInsert} specifies that
inserting an element into a non-empty heap produces a new heap where
the inserted element is a lower bound for the resulting heap if it is smaller than the minimum of the original heap
and that the multiset of elements is updated accordingly.

\begin{code}
heapInsert :: x : a
  -> h1 : LeftistHeap a
  -> {h : LeftistHeap a |
        not (heapIsEmpty h1) 
          => isLowerBound (min x (heapFindMin h1)) h
        && bag h = B.put x (bag h1) }
\end{code}
LiquidHaskell can automatically verify that the properties hold, given the correctness of \texttt{heapMerge}.
So no additional lemmas are required here.


\subsection{Heap SplitMin}

The \texttt{SplitMin} operation decomposes a heap into its minimum element and the remaining heap. 
If the heap is empty, the result is an empty view. 
This operation can be expressed elegantly in LiquidHaskell using a single refinement predicate that encodes both cases,
the empty and non-empty heap, guarded by logical conditions.

\begin{code}
{-@ predicate SplitOK H S =
  (heapIsEmpty H => isEmptyView S)
    && (not (heapIsEmpty H) => not (isEmptyView S)
      && getMinValue S == heapFindMin H
      && bag H == B.put (getMinValue S) (bag (getRestHeap S)))
@-}

{-@ heapSplit :: (Ord a)
              => h:LeftistHeap a
              -> { s:MinView LeftistHeap a | SplitOK h s } @-}
heapSplit :: (Ord a) => LeftistHeap a -> MinView LeftistHeap a
heapSplit EmptyHeap          = EmptyView
heapSplit (HeapNode x l r _) = Min x (heapMerge l r)
\end{code}

The refinement predicate \texttt{SplitOK} expresses the relationship between the input heap \texttt{H} 
and the result \texttt{S} of the \texttt{heapSplit} operation in a case-distinguishing manner:

\begin{itemize}
  \item \textbf{Empty heap case.}  
  When \texttt{heapIsEmpty H} holds, the resulting view \texttt{S} must be empty, i.e., \texttt{isEmptyView S} is true.  
  This ensures that the field selectors \texttt{getMinValue} and \texttt{getRestHeap} are never applied to an empty structure, 
  maintaining totality of the specification.

  \item \textbf{Non-empty heap case.}  
  When \texttt{H} is non-empty, the result must be of the form \texttt{Min} with fields \texttt{minValue} and \texttt{restHeap}.  
  In this branch, the following properties must hold:
  \begin{enumerate}
    \item The minimum value of the view matches the minimum of the input heap:
      \[
        \texttt{getMinValue S = heapFindMin H}.
      \]
    \item The multiset of elements is preserved:
      \[
        \texttt{bag H = B.put (getMinValue S) (bag (getRestHeap S))}.
      \]
  \end{enumerate}
\end{itemize}

The implementation follows the specification precisely. 
For an empty heap, \texttt{heapSplit} simply returns \texttt{EmptyView}. 
For a non-empty heap of the form \texttt{HeapNode x l r \_}, the result is \texttt{Min x (heapMerge l r)}.
The correctness of this implementation relies on two key facts:

\begin{enumerate}
  \item The root element \texttt{x} of a non-empty leftist heap is its minimum, 
        establishing the equality \texttt{getMinValue S == heapFindMin H}.
  \item The \texttt{heapMerge} operation preserves the multiset of elements, 
        ensuring the bag equality in the refinement holds.
\end{enumerate}

Thus, the \texttt{heapSplit} function correctly decomposes any leftist heap into its minimal element and the remainder,
while preserving both structural and content invariants as captured by \texttt{SplitOK}.
\section{Verification of Binomial Heaps (Selected Parts)}
\label{sec:verify-binomial}
This section connects to the implementation in Chapter~\ref{ch:impl},
(\S\ref{sec:binomial-impl}) and presents proofs for the parts currently
mechanized in code: (i) the \emph{pennant} and its internal tree invariants,
(ii) the \emph{link}/\texttt{merge} of two pennants, (iii) rank-correctness of
bit-level addition (\texttt{bSum}, \texttt{bCarry}, \texttt{bHalfAdder}, \texttt{bFullAdder}),
and (iv) the termination and rank consistency of \texttt{addWithCarry}.
We deliberately \emph{omit} proofs for \texttt{findMin} and \texttt{splitMin} at this stage.

\subsection{Pennants and Internal Tree Invariants}
\label{sec:binomial-pennant}

We model the pennant as a root key with an internal perfect tree (the ``bin'')
that holds the remaining elements. We expose its height to the logic and
assert the lower-bound property at every node. In LiquidHaskell notation:
\begin{code}
type BinTreeBound a X = {b : BinTree a | isLowerBound X b}
data BinTree a = Empty
      | Bin { value :: a
          ,left  :: BinTreeBound a value
          ,right :: BinTreeHeight a (bheight left)
          ,height :: {h : Nat | h == 1 + bheight right}
           }
\end{code}
The refined \texttt{Pennant} type asserts that the internal tree is a lower-bounded
perfect tree of the advertised size:
\begin{code}
data Pennant a = P { root :: a
           ,size  :: Nat
           ,bin   :: {b : BinTreeBound a root | bheight b == size}
           }
\end{code}
These refined data types directly encode the invariants for pennants described in Chapter~\ref{ch:impl}:
\begin{itemize}
    \item {\textbf{Minimum Property}:} The refinement on the \texttt{bin} field, \texttt{\{b:BinTreeBound a root | ...\}}, ensures that the pennant's \texttt{root} is a lower bound for all elements in its internal tree \texttt{bin}. This is because \texttt{BinTreeBound a root} is an alias for \texttt{\{h : BinTree a | isLowerBound root h\}}.

    \item {\textbf{Perfect Binary Property}:} The structure of \texttt{BinTree} guarantees that it is a perfect binary tree. The refinement \texttt{right :: BinTreeHeight a (bheight left)} enforces that the left and right children of any node have the same height (\texttt{bheight left == bheight right}). The rank of a node is then one greater than its children's height, which is the definition of a perfect binary tree. The \texttt{bheight b == size} check in the \texttt{Pennant} type connects the pennant's size to the height of its internal tree.

    \item {\textbf{Internal Heap Property}:} Chapter~\ref{ch:impl} describes a \emph{Left-ordering Property}. Our verified implementation uses a standard heap property within the internal \texttt{BinTree} instead. The refinement \texttt{left :: BinTreeBound a value} on the \texttt{Bin} constructor requires that a node's \texttt{value} is a lower bound for its own \texttt{left} subtree. This is a sufficient condition for the correctness of the \texttt{merge} operation on pennants.
\end{itemize}

\subsection{Pennant Operations}

\subsubsection{Singleton Pennant}
Creating a singleton pennant, which represents a single element, is a simple operation. The refined type ensures that it correctly forms a pennant of size 0.
\begin{code}
{-@ singleton :: Ord a => a -> {v:Pennant a | psize v == 0} @-}
singleton :: (Ord a) => a -> Pennant a
singleton x = P x 0 Empty
\end{code}
The implementation creates a pennant with the given element \texttt{x} as the root, a size of 0, and an \texttt{Empty} tree as its \texttt{bin}. LiquidHaskell verifies this is valid because \texttt{bheight Empty} is 0, and \texttt{isLowerBound x Empty} is trivially true.

\subsubsection{Link Pennants}
The core operation on pennants is merging two pennants of the same size \(k\) into one of size \(k+1\).
The refined signature guarantees the size increase and, more importantly, that the resulting pennant preserves the invariants.
\begin{code}
{-@ reflect link @-}
{-@ link :: Ord a => t1:Pennant a
    -> t2:{t:Pennant a | psize t == psize t1}
    -> {v:Pennant a | psize v == psize t1 + 1} @-}
link :: (Ord a) => Pennant a -> Pennant a -> Pennant a
link (P x1 s1 t1) (P x2 s2 t2)
  | x1 <= x2 = P x1 (s1 + 1) (Bin x2 t2 t1 (bheight t1 + 1))
      `withProof` lemma_isLowerBound_transitive x1 x2 t2
  | otherwise = P x2 (s1 + 1) (Bin x1 t1 t2 (s1 + 1))
      `withProof` lemma_isLowerBound_transitive x2 x1 t1
\end{code}
The implementation chooses the smaller of the two roots (\texttt{x1} or \texttt{x2}) as the new root. The other pennant's root and tree are used to form a new \texttt{BinTree} node that becomes the \texttt{bin} of the resulting pennant.

Verification of this function hinges on proving that the new pennant satisfies the \emph{Minimum Property}. For example, in the \texttt{x1 <= x2} case, the new root is \texttt{x1}. The new internal tree is \texttt{Bin x2 t2 t1 ...}. To prove \texttt{isLowerBound x1 (Bin x2 t2 t1 ...)}, we must show:
\begin{enumerate}
    \item \texttt{x1 <= x2}, which is given by the conditional.
    \item \texttt{isLowerBound x1 t1}, which is true because \texttt{t1} was the \texttt{bin} of the pennant rooted at \texttt{x1}.
    \item \texttt{isLowerBound x1 t2}, which requires a proof. We know \texttt{x1 <= x2} and \texttt{isLowerBound x2 t2} (from the input pennant \texttt{t2}). The property follows from transitivity.
\end{enumerate}
This final step is not obvious to the SMT solver, so we provide an explicit proof using the \texttt{lemma\_isLowerBound\_transitive}, which is identical in function to the one used for Leftist Heaps (\S\ref{sec:verify-leftist}). This lemma proves that if \texttt{x <= y} and \texttt{y} is a lower bound for a tree, then \texttt{x} is also a lower bound.

\subsection{Bit-level Addition and Rank Correctness}
The merge operation for binomial heaps is analogous to binary addition. The heap is a list of bits (\texttt{Zero} or \texttt{One}), and merging is a ripple-carry add. LiquidHaskell is used to prove that the ranks of these bits are handled correctly throughout the addition logic.

Each bit is tagged with its rank (or order).
\begin{code}
data BinomialBit a =
      Zero { zorder :: Nat }
    | One  { oorder :: Nat, pennant :: {p:Pennant a | psize p == oorder}}
\end{code}
A \texttt{BinomialHeap} is a list of these bits, with ranks strictly increasing by one at each step. This is enforced by a refined \texttt{PList} type from LiquidHaskell's prelude.
\begin{code}
type BinomialHeap a = PList <{\hd v -> rank hd == rank v - 1}> (BinomialBit a)
\end{code}

The adder logic is built from \texttt{bSum} and \texttt{bCarry} functions, which are combined into half-adders and full-adders. Their refined types guarantee rank-correctness.
\begin{code}
bSum:: b1:BinomialBit a -> b2:{b:BinomialBit a | rank b == rank b1}
         -> {b:BinomialBit a | rank b == rank b1}

bCarry:: b1:{b:BinomialBit a | rank b >= 0}
          -> b2:{b:BinomialBit a | rank b == rank b1}
          -> {b:BinomialBit a | rank b == rank b1 + 1}
\end{code}
\texttt{bSum} produces a bit of the same rank, while \texttt{bCarry} produces a carry bit of the next higher rank. These are composed into a full-adder, which also guarantees correct output ranks for its sum and carry bits.
\begin{code}
bFullAdder :: b1:BinomialBit a
    -> b2:{b:BinomialBit a | rank b == rank b1}
    -> c:{b:BinomialBit a | rank b == rank b1}
    -> (BinomialBit a, BinomialBit a)
        <{\s co -> rank s == rank b1 && rank co == rank b1 + 1}> 
\end{code}
These rank-preserving properties are essential for the main merge algorithm, \texttt{addWithCarry}, to produce a valid \texttt{BinomialHeap}.

\subsection{Heap Merging with \texttt{addWithCarry}}
The function \texttt{addWithCarry} implements the ripple-carry addition recursively over the lists of bits. Its refined type is complex, mainly to ensure that the carry bit passed between recursive calls has the expected rank.
\begin{code}
addWithCarry :: h1:BinomialHeap a
    -> h2:{BinomialHeap a | (bRank h2 == bRank h1 || isNil h1) 
                            || isNil h2}
    -> carry:{c:BinomialBit a | ((not isNil h1) => rank carry == bRank h1)
                              && ((not isNil h2) => rank carry == bRank h2)}
    -> {b:BinomialHeap a | ...} 
    / [len h1, len h2, 0]
\end{code}
The key properties verified by LiquidHaskell are:
\begin{itemize}
    \item \textbf{Termination:} The function terminates, which is guaranteed by the lexicographic metric \texttt{/ [len h1, len h2, 0]}, as each recursive call consumes at least one of the input lists.
    \item \textbf{Rank Propagation:} The precondition on \texttt{carry} ensures that its rank matches the rank of the bits being processed. For a recursive call, the new carry \texttt{c'} is generated by \texttt{bFullAdder}. We must prove that \texttt{rank c'} matches the rank of the next bits in the lists. The \texttt{PList} invariant that ranks increase by 1 at each step is crucial here. For example, if we process bit \texttt{x} and recurse on \texttt{xs}, the new carry \texttt{c'} will have rank \texttt{rank x + 1}. The \texttt{PList} invariant ensures that the head of \texttt{xs} also has rank \texttt{rank x + 1}, so the precondition for the recursive call holds.
\end{itemize}
Lemmas like \texttt{lemma\_rank\_preservation} are used to explicitly prove to the solver that the sum bit produced by the full adder has the correct rank to be prepended to the result of the recursive call, thus maintaining the \texttt{BinomialHeap} invariant.

\paragraph{Out-of-scope (not verified here).}
We do \emph{not} include proofs for \texttt{findMin} and \texttt{splitMin}; these would
require additional invariants over the list-of-bits representation (argmin over
roots and dismantling the perfect tree), which we leave as future work.



