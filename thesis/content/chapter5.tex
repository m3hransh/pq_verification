\chapter{Verification in LiquidHaskell}
\label{ch:verification}
This chapter verifies our priority queue implementations using LiquidHaskell.
We first factor out the common logical infrastructure used by both heaps
(\S\ref{sec:shared-infra}), then present the leftist-heap development
(\S\ref{sec:verify-leftist}), and finally \emph{only} those parts of the
binomial heap for which we currently have mechanized proofs (\S\ref{sec:verify-binomial}).
Throughout, we refer back to Chapter~\ref{ch:lh} for the LiquidHaskell
features we rely on (reflection, measures, PLE, and termination).

\section{Shared Logical Infrastructure}
\label{sec:shared-infra}

We reuse LiquidHaskell features introduced in Chapter~\ref{ch:lh}:
\begin{itemize}
  \item \textbf{Measures and refined data types} (\S\ref{sec:reflection}--\ref{sec:lh-refined-datatypes})
        to expose structural invariants to the refinement logic.
  \item \textbf{Reflection and equational reasoning} (\S\ref{sec:reflection}, \S\ref{sec:proofs})
        for unfolding definitions during proofs.
  \item \textbf{Proof by Logical Evaluation (PLE)} (\S\ref{sec:lh-ple}) to automate unfolding-driven proofs.
  \item \textbf{Termination metrics} (\S\ref{sec:termination}) using size/height and lexicographic tuples.
\end{itemize}

We also standardize the following predicate, reused by both heaps:
\[
\mathsf{isLowerBound}\ v\ t \ \triangleq\ v \le \text{every element of } t,
\]
so that lower-bound obligations can be phrased uniformly for tree- and heap-shaped structures.

\section{Verification of Leftist Heaps}
\label{sec:verify-leftist}
The cornerstone of the verification is the refined data type for the leftist heap itself.
We encode the core invariants of the data structure directly into its type definition.
In LiquidHaskell notation, the refined \texttt{LeftistHeap} type is defined as follows:

\begin{code}
data LeftistHeap a 
  = EmptyHeap
  | HeapNode { value :: a
             , left  :: LeftistHeapBound a value
             , right :: {v : LeftistHeapBound a value  | rrank v <= rrank left }
             , rank :: {r : Nat | r == 1 + rrank right}
             }
\end{code}

This refined definition enforces three key invariants:
\begin{enumerate}
    \item \textbf{Heap Property:} The value at any node is the minimum in its subtree.
    This is captured by the \texttt{LeftistHeapBound a X} refinement type on the \texttt{left} and \texttt{right} children.
    \texttt{isLowerBound} is a recursively defined predicate that checks if a given value is less than or equal to all elements in a heap.
    \begin{code}
{-@ type LeftistHeapBound a X = { h : LeftistHeap a | isLowerBound X h} @-}
{-@ reflect isLowerBound @-} 
isLowerBound :: (Ord a) => a -> LeftistHeap a -> Bool
isLowerBound _ EmptyHeap = True
isLowerBound v (HeapNode x l r _) = 
    v <= x && isLowerBound v l && isLowerBound v r
    \end{code}
    
    \item \textbf{Leftist Property:} For any node, the rank of its right child is less than or equal to the rank of its left child. This is expressed by \texttt{rrank v <= rrank left}. This property is what ensures that the right spine of the heap is short, leading to logarithmic time complexity for merge operations.
    
    \item \textbf{Rank Property:} The rank of a node is defined as one plus the rank of its right child. This is specified by \texttt{rank :: \{r : Nat | r == 1 + rrank right\}}. The rank of an \texttt{EmptyHeap} is 0.
\end{enumerate}

By embedding these invariants directly into the type, \texttt{LiquidHaskell}'s verifier will ensure that any function constructing or modifying a \texttt{LeftistHeap} respects them.

Following the interface defined in Chapter~\ref{lst:pq}, we refine the types of the heap operations to ensure they maintain the invariants of the leftist heap.
Unfortunately, due to limitations in \texttt{LiquidHaskell}'s current support for type classes,
we cannot directly define the invariants for the \texttt{PriorityQueue} type class.
Instead, we provide refined type signatures for each operation individually.
To express these invariants and reason about the behavior of our functions, we use several features of \texttt{LiquidHaskell}.

\textbf{Measures} (see \S\ref{sec:reflection}) are functions from Haskell's term-level to the refinement logic's domain. We define several measures:
\begin{itemize}
	\item \texttt{size}: Computes the total number of nodes in the heap, useful for termination metrics (see \S\ref{sec:termination}).
	\item \texttt{rrank}: Returns the rank of a heap, which is crucial for the leftist property.
	\item \texttt{bag}: Converts the heap into a multiset (or bag) of its elements. This is invaluable for proving that operations like \texttt{heapMerge} do not lose or duplicate elements.
\end{itemize}

\textbf{Reflected Functions} (see \S\ref{sec:reflection}) allow us to use standard Haskell functions within the refinement logic. We use this for \texttt{isLowerBound}, \texttt{heapMerge}, and \texttt{makeHeapNode}.
This allows us to reason about their behavior during verification.


In the following sections,
we present the refined type signatures and implementations of the key heap operations,
along with explanations of how they maintain the invariants of the leftist heap.
\subsection{Heap isEmpty}
This function checks if the heap is empty.
There is no invariate to maintain here, but we define a measure to help with other proofs.
\begin{code}
{-@ measure heapIsEmpty @-}
{-@ heapIsEmpty :: LeftistHeap a -> Bool @-}
heapIsEmpty :: (Ord a) => LeftistHeap a -> Bool
heapIsEmpty EmptyHeap = True
heapIsEmpty _ = False
\end{code}
\subsection{Heap findMin}
To retrieve the minimum element from a non-empty heap, we define \texttt{heapFindMin}.
We restrict its input to non-empty heaps and specify that the returned value is a lower bound for the heap.
As per the heap property, the minimum element is always at the root of the heap.
This can directly be extracted from the \texttt{HeapNode} and \texttt{LiquidHaskell} can verify that this value is indeed a lower bound for the entire heap.
\begin{code}
{-@ heapFindMin :: h : {h : LeftistHeap a | not (heapIsEmpty h)} 
      -> {v : a | isLowerBound v h} @-}
heapFindMin :: (Ord a) => LeftistHeap a -> a
heapFindMin (HeapNode x _ _ _) = x
\end{code}

\subsection{Heap Merge}
The most critical operation for a leftist heap is \texttt{heapMerge}. 
Its correctness is fundamental to the correctness of \texttt{insert} and \texttt{deleteMin}.
The type signature for \texttt{heapMerge} specifies its behavior:
\begin{code}
heapMerge :: h1 : LeftistHeap a 
  -> h2 : LeftistHeap a 
  -> {h : LeftistHeap a | (HeapMergeMin h1 h2 h) && (BagUnion h1 h2 h)}
  / [size h1, size h2, 0]
\end{code}
This signature guarantees that merging two valid leftist heaps results in a new valid leftist heap,
that the heap property is maintained, and that the set of elements is preserved.

To express these properties, we have defined two predicates:
\begin{code}
predicate HeapMergeMin H1 H2 H = 
  ((not (heapIsEmpty H1) && not (heapIsEmpty H2)) => 
  isLowerBound (min (heapFindMin H1) (heapFindMin H2)) H )
predicate BagUnion H1 H2 H = 
  (bag H == B.union (bag H1) (bag H2))
\end{code}

\texttt{HeapMergeMin} asserts that the resulting heap \texttt{H} respects the heap property relative to the minimum elements of the input heaps \texttt{H1} and \texttt{H2}.
\texttt{BagUnion} asserts that the elements in the merged heap are the union of the elements from the input heaps.

The implementation of \texttt{heapMerge} involves a recursive call.
To help the SMT solver prove that the invariants hold through this recursion,
we provide helper lemmas. For example, in the case where \texttt{x1 <= x2},
we merge the right child of the first heap (\texttt{r1}) with the second heap (\texttt{h2}).
We must provide the proof for \texttt{LiquidHaskell} that the root value \texttt{x1} is a lower bound for this newly merged heap.

\begin{code}
heapMerge h1@(HeapNode x1 l1 r1 _) h2@(HeapNode x2 l2 r2 _)
| x1 <= x2 = makeHeapNode x1 l1 ((heapMerge r1 h2) 
  `withProof` lemma_merge_case1 x1 x2 r1 h2)
| otherwise = makeHeapNode x2 l2 ((heapMerge h1 r2)
  `withProof` lemma_heapMerge_case2 x2 x1 r2 h1)
\end{code}

The \texttt{makeHeapNode} requires that its first argument is a lower bound for both its left and right children.
\begin{code}
makeHeapNode :: x : a
 -> {h : LeftistHeap a | isLowerBound x h}
 -> {h : LeftistHeap a | isLowerBound x h}
 -> {h : LeftistHeap a | isLowerBound x h}
\end{code}
In this context, \texttt{LiquidHaskell} can automatically infer that the root value (\texttt{x1} or \texttt{x2}) is a lower bound for the left child, since it is inherited from the parent heap.
However, for the right child, which is obtained from a recursive call to \texttt{heapMerge}, the proof must be supplied explicitly.
This proof obligation is discharged by auxiliary lemmas such as \texttt{lemma\_merge\_case1} and \texttt{lemma\_merge\_case2}.

The first lemma, \texttt{lemma\_merge\_case1}, handles the case where \texttt{x1 <= x2}.
It states that if \texttt{x1} is a lower bound for \texttt{r1} and \texttt{x2} is a lower bound for \texttt{h2}, then \texttt{x1} is also a lower bound for the result of merging \texttt{r1} and \texttt{h2}.
\begin{code}
lemma_merge_case1 :: x1 : a
  -> x2 : {a |  x1  <= x2}
  -> r1 : LeftistHeapBound a x1
  -> h2 : {LeftistHeapBound a x2 | not (heapIsEmpty h2)}
  -> {isLowerBound x1 (heapMerge r1 h2)}
  / [size r1, size h2, 1]
\end{code}

The proof proceeds by case analysis on the structure of \texttt{r1}.

\begin{code}
lemma_merge_case1 x1 x2 EmptyHeap h2 =
  isLowerBound x1 (heapMerge EmptyHeap h2)
    ? lemma_isLowerBound_transitive x1 x2 h2
    *** QED
lemma_merge_case1 x1 x2 r1@(HeapNode _ _ _ _) h2@(HeapNode _ _ _ _) =
  isLowerBound x1 (heapMerged)
    ? (lemma_isLowerBound_transitive x1 (min (heapFindMin r1) (heapFindMin h2)) (heapMerged))
    *** QED
 where
  heapMerged = heapMerge r1 h2
\end{code}

In the base case, when \texttt{r1} is empty, the merge simply returns \texttt{h2}.
Since \texttt{x1 <= x2} and \texttt{x2} is a lower bound for \texttt{h2}, it follows by transitivity that \texttt{x1} is also a lower bound for \texttt{h2}.
In the inductive case, both heaps are non-empty.
The result of \texttt{heapMerge r1 h2} again satisfies the lower-bound property, which is established through the transitive lemma below.


\subsubsection{Transitivity of Lower Bounds}
The lemma \texttt{lemma\_isLowerBound\_transitive} expresses the fundamental transitivity of the lower-bound relation across heaps.
It is used repeatedly throughout the verification of heap merge.
\begin{code}
{-@ lemma_isLowerBound_transitive :: x : a
      -> y : {v : a | x <= v}
      -> h : {h : LeftistHeap a | isLowerBound y h}
      -> {isLowerBound x h}
@-}
lemma_isLowerBound_transitive :: 
  (Ord a) => a
          -> a
          -> LeftistHeap a
          -> Proof
lemma_isLowerBound_transitive x y EmptyHeap = ()
lemma_isLowerBound_transitive x y (HeapNode z l r _) = lemma_isLowerBound_transitive x y l &&& lemma_isLowerBound_transitive x y r *** QED
\end{code}

This lemma formalizes the intuitive notion that if \texttt{x <= y} and \texttt{y} is a lower bound for all elements of a heap \texttt{h}, then \texttt{x} must also be a lower bound for \texttt{h}.
It is a small but essential proof component that supports most of the recursive heap reasoning.

\subsubsection{Symmetric Case}
A symmetric argument applies to the case where \texttt{x1 > x2}.
The second lemma, \texttt{lemma\_merge\_case2}, follows the same structure as \texttt{lemma\_merge\_case1} but exchanges the roles of the input heaps and their bounds.

\begin{code}
lemma_heapMerge_case2 :: x2 : a
  -> x1 : { v : a |  x2  <= v}
  -> r1 : {h : LeftistHeap a | isLowerBound x2 h}
  -> h2 : {h : LeftistHeap a | not (heapIsEmpty h) && isLowerBound x1 h}
  -> {isLowerBound x2 (heapMerge h2 r1)} 
  / [size h2, size r1, 1]
\end{code}
The reason we cannot simply reuse \texttt{lemma\_merge\_case1} is that the order of the arguments to \texttt{heapMerge} is swapped in this case.
And also the termination metric must reflect which arguments are reduced in the recursive call.
We discuss this in the next section.

\subsubsection{Dealing with Termination and Recursion}

\texttt{LiquidHaskell} must ensure that all recursive functions terminate. 
For \texttt{heapMerge}, we provide the following termination metric:

\begin{code}
/ [size h1, size h2, 0]
\end{code}

This specifies a lexicographically ordered tuple. 
\texttt{LiquidHaskell} verifies that for every recursive call within \texttt{heapMerge}, either the size of the first argument or the size of the second argument decreases. 
In our case, one of the heaps is replaced by its right child, which is strictly smaller, thereby decreasing the total size and ensuring termination. 
The trailing \texttt{0} acts as a tie-breaker: it allows us to extend the tuple later when reasoning about mutually recursive functions.

The lemma \texttt{lemma\_merge\_case1} is mutually recursive with \texttt{heapMerge}, which requires us to make explicit which arguments of \texttt{heapMerge} are reduced in the body of the function (for instance, \texttt{r1} compared to \texttt{h1}). 
To capture this, we use the following termination metric for \texttt{lemma\_merge\_case1}:

\begin{code}
/ [size r1, size h2, 1]
\end{code}

Here the final \texttt{1} ensures that 
\[
[size\ r1, size\ h2, 0] \;<\; [size\ r1, size\ h2, 1]
\]
in lexicographic order. 
This indicates that when \texttt{lemma\_merge\_case1} calls \texttt{heapMerge}, it is making progress towards termination.
In the same way, other supporting lemmas are also assigned termination metrics, which are automatically checked by the verifier.


Together, these lemmas ensure that \texttt{heapMerge} preserves the heap property and terminates correctly for all valid inputs.
They form the core of the mechanized proof that merging two leftist heaps yields a well-formed, correctly ordered, and element-preserving result.
\subsection{Heap Insert}
Heap insertion is implemented using heap merging.
The refined type signature for \texttt{heapInsert} specifies that
inserting an element into a non-empty heap produces a new heap where
the inserted element is a lower bound for the resulting heap if it is smaller than the minimum of the original heap
and that the multiset of elements is updated accordingly.

\begin{code}
heapInsert :: x : a
  -> h1 : LeftistHeap a
  -> {h : LeftistHeap a |
        not (heapIsEmpty h1) 
          => isLowerBound (min x (heapFindMin h1)) h
        && bag h = B.put x (bag h1) }
\end{code}
LiquidHaskell can automatically verify that the properties hold, given the correctness of \texttt{heapMerge}.
So no additional lemmas are required here.


\subsection{Heap SplitMin}

The \texttt{SplitMin} operation decomposes a heap into its minimum element and the remaining heap. 
If the heap is empty, the result is an empty view. 
This operation can be expressed elegantly in LiquidHaskell using a single refinement predicate that encodes both cases,
the empty and non-empty heap, guarded by logical conditions.

\begin{code}
{-@ predicate SplitOK H S =
  (heapIsEmpty H => isEmptyView S)
    && (not (heapIsEmpty H) => not (isEmptyView S)
      && getMinValue S == heapFindMin H
      && bag H == B.put (getMinValue S) (bag (getRestHeap S)))
@-}

{-@ heapSplit :: (Ord a)
              => h:LeftistHeap a
              -> { s:MinView LeftistHeap a | SplitOK h s } @-}
heapSplit :: (Ord a) => LeftistHeap a -> MinView LeftistHeap a
heapSplit EmptyHeap          = EmptyView
heapSplit (HeapNode x l r _) = Min x (heapMerge l r)
\end{code}

The refinement predicate \texttt{SplitOK} expresses the relationship between the input heap \texttt{H} 
and the result \texttt{S} of the \texttt{heapSplit} operation in a case-distinguishing manner:

\begin{itemize}
  \item \textbf{Empty heap case.}  
  When \texttt{heapIsEmpty H} holds, the resulting view \texttt{S} must be empty, i.e., \texttt{isEmptyView S} is true.  
  This ensures that the field selectors \texttt{getMinValue} and \texttt{getRestHeap} are never applied to an empty structure, 
  maintaining totality of the specification.

  \item \textbf{Non-empty heap case.}  
  When \texttt{H} is non-empty, the result must be of the form \texttt{Min} with fields \texttt{minValue} and \texttt{restHeap}.  
  In this branch, the following properties must hold:
  \begin{enumerate}
    \item The minimum value of the view matches the minimum of the input heap:
      \[
        \texttt{getMinValue S = heapFindMin H}.
      \]
    \item The multiset of elements is preserved:
      \[
        \texttt{bag H = B.put (getMinValue S) (bag (getRestHeap S))}.
      \]
  \end{enumerate}
\end{itemize}

The implementation follows the specification precisely. 
For an empty heap, \texttt{heapSplit} simply returns \texttt{EmptyView}. 
For a non-empty heap of the form \texttt{HeapNode x l r \_}, the result is \texttt{Min x (heapMerge l r)}.
The correctness of this implementation relies on two key facts:

\begin{enumerate}
  \item The root element \texttt{x} of a non-empty leftist heap is its minimum, 
        establishing the equality \texttt{getMinValue S == heapFindMin H}.
  \item The \texttt{heapMerge} operation preserves the multiset of elements, 
        ensuring the bag equality in the refinement holds.
\end{enumerate}

Thus, the \texttt{heapSplit} function correctly decomposes any leftist heap into its minimal element and the remainder,
while preserving both structural and content invariants as captured by \texttt{SplitOK}.
\section{Verification of Binomial Heaps}
\label{sec:verify-binomial}
Building upon the verification techniques established for leftist heaps (\S\ref{sec:verify-leftist}),
this section presents the verification of binomial heaps.
The binomial heap structure, described in Chapter~\ref{ch:impl} (\S\ref{sec:binomial-impl}),
is more intricate than leftist heaps, requiring a compositional approach across three data structure layers.
We verify: (i) the \emph{pennant} and its internal tree invariants,
(ii) the \emph{link} operation for merging two pennants, (iii) rank-correctness of
bit-level addition (\texttt{bSum}, \texttt{bCarry}, \texttt{bHalfAdder}, \texttt{bFullAdder}),
and (iv) the termination and rank consistency of \texttt{addWithCarry}.
As with leftist heaps, we leverage the shared logical infrastructure (\S\ref{sec:shared-infra}),
particularly the \texttt{isLowerBound} predicate for expressing heap properties.

\subsection{Refined Data Structures}
\label{sec:binomial-pennant}

Following the pattern established for leftist heaps (\S\ref{sec:verify-leftist}), we encode
the binomial heap's structural invariants directly into refined data types.
The binomial heap implementation (Chapter~\ref{ch:impl}, \S\ref{sec:binomial-impl}) 
is built from three nested structures: binary trees, pennants, and bit-level heaps.
Each layer is verified through appropriate refinements.

\subsubsection{Binary Trees with Left-Ordering}

The foundation is a perfect binary tree with a left-ordering property rather than a full heap property.
We reuse the \texttt{isLowerBound} predicate from the shared infrastructure (\S\ref{sec:shared-infra}),
but apply it only to the left child. The refined \texttt{BinTree} type ensures both left-ordering
and perfect balance:
\begin{code}
type BinTreeBound a X = {b : BinTree a | isLowerBound X b}
data BinTree a = Empty
      | Bin { value  :: a
            , left   :: BinTreeBound a value
            , right  :: BinTreeHeight a (bheight left)
            , height :: {h : Nat | h == 1 + bheight right}
            }
\end{code}
\texttt{bheight} is a measure that computes the height of a \texttt{BinTree}:
\begin{code}

{-@ measure bheight @-}
{-@ bheight :: BinTree a -> {v: Int | v >= -1} @-}
bheight :: BinTree a -> Int
bheight Empty = -1
bheight (Bin _ _ _ h) = h
\end{code}

\subsubsection{Pennants}

A pennant wraps a binary tree with its root element. The refined \texttt{Pennant} type
enforces the \textbf{Minimum Property} from Chapter~\ref{ch:impl}---the root is less than
or equal to all elements in the internal tree:
\begin{code}
data Pennant a 
  = P 
  { root    :: a
  , pheight :: Nat
  , bin     :: {b : BinTreeBound a root | bheight b + 1 = pheight}
  }
\end{code}

The refinement \texttt{bin :: \{b : BinTreeBound a root | ...\}} ensures \\ \texttt{isLowerBound root bin},
capturing the \textbf{Minimum Property}. The height constraint \texttt{bheight b + 1 = pheight}
connects the pennant's advertised height to its internal tree structure.

Together with the \texttt{BinTree} definition, the three invariants from Chapter~\ref{ch:impl} are enforced:
\begin{enumerate}
    \item \textbf{Minimum Property:} The \texttt{Pennant} refinement \texttt{bin :: BinTreeBound a root}
    ensures that the pennant's root is a lower bound for all elements in its internal tree
    (\texttt{isLowerBound root bin}).

    \item \textbf{Left-ordering Property:} Within the internal \texttt{BinTree}, the refinement
    \texttt{left :: BinTreeBound a value} ensures that each node's value is a lower bound for its
    left subtree (\texttt{isLowerBound value left}). This means for every node, the left child's
    value is less than or equal to the right child's value. Note that this is \emph{weaker} than
    the full heap property used in leftist heaps (\S\ref{sec:verify-leftist})---we only enforce
    ordering between the parent and left child, not both children.

    \item \textbf{Perfect Binary Tree Property:} The \texttt{BinTree} refinement
    \texttt{right :: BinTreeHeight a (bheight left)} enforces that both subtrees have identical height.
    Combined with the height correctness constraint \texttt{height :: \{h:Nat | h == 1 + bheight right\}},
    this ensures the tree is perfectly balanced: all internal nodes have two subtrees of equal height,
    and all leaves are at the same level.
\end{enumerate}

\subsection{Pennant Operations}

\subsubsection{Singleton Pennant}
Creating a singleton pennant, which represents a single element, is a simple operation. The refined type ensures that it correctly forms a pennant of size 0.
\begin{code}
{-@ singleton :: Ord a => a -> {v : Pennant a | pheight v == 0} @-}
singleton :: (Ord a) => a -> Pennant a
singleton x = P x 0 Empty
\end{code}
The implementation creates a pennant with the given element \texttt{x} as the root, a size of 0, and an \texttt{Empty} tree as its \texttt{bin}. LiquidHaskell verifies this is valid because \texttt{bheight Empty} is 0, and \texttt{isLowerBound x Empty} is trivially true.

\subsubsection{Link Pennants}
The core operation on pennants is merging two pennants of the same height \(h\) into one of height \(h+1\).
The refined signature guarantees the height increase, ensures that all elements of the merging pennants exist, and, more importantly, that the resulting pennant preserves the invariants.
\begin{code}
{-@ reflect link @-}
{-@ link :: Ord a => t1 : Pennant a
    -> t2 : {Pennant a | pheight t2 == pheight t1}
    -> {v : Pennant a | pheight v == pheight t1 + 1 && BagUnion t1 t2 v} @-}
link :: (Ord a) => Pennant a -> Pennant a -> Pennant a
link (P x1 h1 t1) (P x2 h2 t2)
  | x1 <= x2 
    = P x1 (h1 + 1) (Bin x2 t2 t1 (h1))
       `withProof` lemma_isLowerBound_transitive x1 x2 t2
  | otherwise 
    = P x2 (h1 + 1) (Bin x1 t1 t2 (h1))
       `withProof` lemma_isLowerBound_transitive x2 x1 t1
\end{code}
The implementation chooses the smaller of the two roots (\texttt{x1} or \texttt{x2}) as the new root. The other pennant's root and tree are used to form a new \texttt{BinTree} node that becomes the \texttt{bin} of the resulting pennant.

Verification of this function hinges on proving that the new pennant satisfies the \emph{Minimum Property}. For example, in the \texttt{x1 <= x2} case, the new root is \texttt{x1}. The new internal tree is \texttt{Bin x2 t2 t1 ...}. To prove \texttt{isLowerBound x1 (Bin x2 t2 t1 ...)}, we must show:
\begin{enumerate}
    \item \texttt{x1 <= x2}, which is given by the conditional.
    \item \texttt{isLowerBound x1 t1}, which is true because \texttt{t1} was the \texttt{bin} of the pennant rooted at \texttt{x1}.
    \item \texttt{isLowerBound x1 t2}, which requires a proof. We know \texttt{x1 <= x2} and \texttt{isLowerBound x2 t2} (from the input pennant \texttt{t2}). The property follows from transitivity.
\end{enumerate}
This final step is not obvious to the SMT solver, so we provide an explicit proof using the \texttt{lemma\_isLowerBound\_transitive}, which is identical in function to the one used for Leftist Heaps (\S\ref{sec:verify-leftist}). This lemma proves that if \texttt{x <= y} and \texttt{y} is a lower bound for a tree, then \texttt{x} is also a lower bound.

\subsection{Binomial Heap Representation and Bit-level Operations}
\label{sec:binomial-bits}

Following Chapter~\ref{ch:impl}, a binomial heap is represented as a list of bits, where each bit
at position $i$ either contains \texttt{Zero} or \texttt{One} pennant of height $i$. This representation
is analogous to the binary representation of a number, enabling efficient merge operations through
bit-level addition.

\subsubsection{Refined Bit Structure}

Each bit is tagged with its rank (order) and refined to ensure rank-height consistency:
\begin{code}
data BinomialBit a 
  = Zero { zorder :: Nat }
  | One  { oorder :: Nat
         , pennant :: {p : Pennant a | pheight p == oorder}
         }
\end{code}
The refinement \texttt{pennant :: \{p : Pennant a | pheight p == oorder\}} ensures that a
\texttt{One} bit at rank $i$ contains a pennant of height $i$.

A \texttt{BinomialHeap} is a list of these bits with ranks strictly increasing by one at each step.
Rather than using LiquidHaskell's parameterized \texttt{PList} type, we define a custom refined
data type that directly encodes the rank-incrementing invariant:

\begin{code}
{-@ data BinomialHeap [len] a =
        Nil
      | Cons { hd :: BinomialBit a
             , tl :: {bs : BinomialHeap a |
                      not (heapIsEmpty bs) =>
                        rank (bhead bs) = rank hd + 1}
             }
@-}
data BinomialHeap a
  = Nil
  | Cons { hd :: BinomialBit a, tl :: BinomialHeap a }
\end{code}

This refinement maintains the binomial heap's structural invariant: if the tail is non-empty, its
first bit's rank must be exactly one more than the current bit's rank. The measure \texttt{len}
provides a termination metric for recursive functions over heaps. We define \texttt{heapIsEmpty}
and \texttt{bhead} as measures to check emptiness and access the first bit:

\begin{code}
{-@ measure heapIsEmpty @-}
heapIsEmpty :: BinomialHeap a -> Bool
heapIsEmpty Nil = True
heapIsEmpty _ = False

{-@ measure bhead @-}
{-@ bhead :: {b:BinomialHeap a | not (heapIsEmpty b)} -> BinomialBit a @-}
bhead :: BinomialHeap a -> BinomialBit a
bhead (Cons a _) = a
\end{code}

Additionally, the measure \texttt{bRank} extracts the rank of a heap's first bit (or 0 for empty heaps),
which is crucial for specifying preconditions on operations like \texttt{bAdd} that require heaps
starting at rank 0:

\begin{code}
{-@ measure bRank @-}
{-@ bRank :: BinomialHeap a -> Nat @-}
bRank :: BinomialHeap a -> Int
bRank Nil = 0
bRank (Cons b bs) = rank b
\end{code}

\subsubsection{Bit Arithmetic Operations}

Following the ripple-carry adder approach from Chapter~\ref{ch:impl}, the merge operation is
implemented through bit-level addition. The \texttt{bSum} and \texttt{bCarry} functions form the
basis of this arithmetic, with refined types guaranteeing rank-correctness:

\begin{code}
bSum :: b1:BinomialBit a -> 
            b2:{BinomialBit a | rank b2 == rank b1} -> 
            {b:BinomialBit a | rank b == rank b1}

bCarry :: Ord a => 
              b1:{BinomialBit a | rank b1 >= 0} -> 
              b2:{BinomialBit a | rank b2 == rank b1} -> 
              {b:BinomialBit a | rank b == rank b1 + 1}
\end{code}

The \texttt{bSum} function produces a bit of the same rank as its inputs, while \texttt{bCarry}
produces a carry bit of the next higher rank. Both functions are reflected into the refinement
logic, enabling LiquidHaskell to reason about their behavior during verification.

These primitives are composed into half-adders and full-adders:

\begin{code}
bHalfAdder :: b1:BinomialBit a ->
                  b2:{BinomialBit a | rank b2 == rank b1} ->
                  ({s:BinomialBit a | rank s == rank b1}, 
                   {c:BinomialBit a | rank c == rank b1 + 1})

bFullAdder :: b1:BinomialBit a ->
                  b2:{BinomialBit a | rank b2 == rank b1} ->
                  c:{BinomialBit a | rank c == rank b1} ->
                  ({s:BinomialBit a | rank s == rank b1}, 
                   {co:BinomialBit a | rank co == rank b1 + 1})
\end{code}

The half-adder takes two bits at rank $r$ and produces a sum at rank $r$ and a carry at rank $r+1$.
The full-adder additionally accepts a carry-in bit at rank $r$, producing the same outputs.
These rank-preserving refinement types ensure that the composed operations maintain heap rank
consistency without requiring explicit rank-preservation lemmas---LiquidHaskell's PLE
(\S\ref{sec:lh-ple}) automatically unfolds the reflected definitions to verify correctness.

\subsection{Heap Merging with \texttt{addWithCarry}}

The function \texttt{addWithCarry} implements the ripple-carry addition recursively over the lists
of bits. Its refined type ensures that the carry bit passed between recursive calls has the expected
rank, and that the output maintains heap rank consistency.

The top-level \texttt{bAdd} function initiates the merge by calling \texttt{addWithCarry} with an
initial carry of \texttt{Zero 0}:

\begin{code}
bAdd :: h1:{BinomialHeap a | bRank h1 == 0} ->
            h2:{BinomialHeap a | bRank h2 == 0} ->
            BinomialHeap a 
bAdd :: (Ord a) => BinomialHeap a -> BinomialHeap a -> BinomialHeap a
bAdd xs ys = addWithCarry xs ys (Zero 0)
\end{code}

The precondition requires both input heaps to start at rank 0, which is maintained by all
priority queue operations through the \texttt{padWithZeros} helper.

The \texttt{addWithCarry} function has a more complex refinement type:

\begin{code}
addWithCarry :: 
      h1:BinomialHeap a ->
      h2:{BinomialHeap a | 
          (bRank h2 == bRank h1 || heapIsEmpty h1) 
          || heapIsEmpty h2} ->
      carry:{BinomialBit a | 
             ((not (heapIsEmpty h1)) => rank carry == bRank h1)
             && ((not (heapIsEmpty h2)) => rank carry == bRank h2)} ->
      {b:BinomialHeap a | 
       (not (heapIsEmpty b)) => rank (bhead b) == rank carry}
      / [len h1, len h2]
\end{code}

The key properties verified by LiquidHaskell are:

\begin{itemize}
    \item \textbf{Rank Alignment:} The precondition ensures that when both heaps are non-empty,
    they have the same starting rank. Additionally, the carry bit's rank must match the starting
    rank of any non-empty input heap.

    \item \textbf{Output Rank:} The postcondition guarantees that if the result is non-empty, its
    first bit has the same rank as the input carry. This ensures that the output heap's structure
    is consistent with the input.

    \item \textbf{Termination:} The lexicographic metric \texttt{/ [len h1, len h2]} proves
    termination, as each recursive call consumes at least one bit from one of the input heaps.
\end{itemize}

The verification relies on the refined types of \texttt{bFullAdder}, which guarantee that the new
sum bit has the correct rank for prepending to the recursive result, and that the new carry bit
has rank $r+1$ for matching the next bits in the lists. The \texttt{BinomialHeap} data type
refinement ensures that consecutive bits differ by exactly one in rank, so when processing bit at
rank $r$, the tail's first bit (if it exists) has rank $r+1$, matching the new carry's rank.

LiquidHaskell's PLE automatically unfolds the reflected definitions of \texttt{bSum}, \texttt{bCarry},
and \texttt{bFullAdder} to verify these rank invariants hold throughout the recursion, eliminating
the need for explicit rank-preservation lemmas.

\subsection{Finding and Extracting Minimum Elements}
\label{sec:binomial-findmin}

The binomial heap's list-of-bits representation requires searching across multiple pennants to find
the global minimum. Unlike leftist heaps where the minimum is always at the root, binomial heaps
must examine the root of each non-empty pennant (each \texttt{One} bit) in the heap.

\subsubsection{Checking for Empty Heaps}

A binomial heap is effectively empty when it contains only \texttt{Zero} bits. The \texttt{hasOnlyZeros}
predicate captures this property:

\begin{code}
{-@ reflect hasOnlyZeros @-}
{-@ hasOnlyZeros :: BinomialHeap a -> Bool @-}
hasOnlyZeros :: BinomialHeap a -> Bool
hasOnlyZeros Nil = True
hasOnlyZeros (Cons (Zero _) bs) = hasOnlyZeros bs
hasOnlyZeros (Cons (One _ _) _) = False
\end{code}

This predicate is reflected into the logic and used as a precondition for operations that require
a non-empty heap.

\subsubsection{Finding the Minimum Root}

The \texttt{minRootInHeap} function searches through the list of bits to find the minimum among
all pennant roots. Its refined type ensures it is only called on heaps containing at least one
\texttt{One} bit:

\begin{code}
{-@ reflect minRootInHeap @-}
{-@ minRootInHeap :: Ord a =>
      h:{BinomialHeap a | not (hasOnlyZeros h)} -> a @-}
minRootInHeap :: (Ord a) => BinomialHeap a -> a
minRootInHeap (Cons (Zero _) bs) = minRootInHeap bs
minRootInHeap (Cons (One _ (P r _ _)) Nil) = r
minRootInHeap (Cons (One _ (P r _ _)) bs@(Cons _ _)) =
  if hasOnlyZeros bs
    then r
    else min r (minRootInHeap bs)
\end{code}

The function recursively skips \texttt{Zero} bits and compares roots of \texttt{One} bits using the
\texttt{min} function (see \S\ref{sec:shared-infra}). The precondition \texttt{not (hasOnlyZeros h)}
ensures the recursion encounters at least one \texttt{One} bit before reaching \texttt{Nil}.

\subsubsection{Extracting the Minimum Pennant}

The \texttt{extractMin} function locates and removes the pennant with the minimum root value,
returning both the pennant and the remaining heap. Its refined type guarantees that the extracted
pennant's root is indeed the minimum:

\begin{code}
{-@ extractMin :: (Ord a) =>
      {h:BinomialHeap a | not (hasOnlyZeros h)} ->
      ({p:Pennant a | minRootInHeap h == root p},
       {h':BinomialHeap a |
         (not (heapIsEmpty h') => rank (bhead h') == rank (bhead h))
         && (bRank h == 0 => (heapIsEmpty h' || bRank h' == 0))}) @-}
\end{code}

The implementation traverses the bit list, comparing roots and recursively extracting from the
tail when necessary. The refinement ensures:
\begin{itemize}
    \item The extracted pennant's root equals \texttt{minRootInHeap h}.
    \item The remaining heap maintains rank consistency (if non-empty, its first bit has the same rank).
    \item If the input heap starts at rank 0, the output heap is either empty or also starts at rank 0.
\end{itemize}

The verification relies on comparing roots using the \texttt{min} function and the transitivity
of the $\leq$ relation, which PLE can establish automatically.

\subsection{Dismantling Pennants and Reversing Heaps}
\label{sec:binomial-dismantle}

The \texttt{splitMin} operation requires converting the internal tree of the minimum pennant back
into a binomial heap. This involves two key operations: dismantling a perfect binary tree into a
reversed bit-list, and reversing that list back to standard form.

\subsubsection{Reversed Binomial Heaps}

To efficiently convert a binary tree to a binomial heap, we use an auxiliary data structure with
\emph{decreasing} ranks:

\begin{code}
data ReversedBinomialHeap [rlen] a =
        RNil
      | RCons { rhd :: BinomialBit a
              , rtl :: {bs : ReversedBinomialHeap a |
                       not (isRNil bs) =>
                         rank (rbhead bs) = rank rhd - 1}
              }
\end{code}

This structure is the mirror image of \texttt{BinomialHeap}: consecutive bits differ by $-1$ in rank
rather than $+1$. The refinement ensures that ranks decrease strictly by one at each step.

\subsubsection{Dismantling a Binary Tree}

The \texttt{dismantle} function converts a perfect binary tree into a reversed bit-list. At each
level of the tree, it creates a \texttt{One} bit containing a pennant formed from the current
node's value and left subtree:

\begin{code}
{-@ reflect dismantle @-}
{-@ dismantle :: Ord a =>
      t:BinTree a ->
      {rh:ReversedBinomialHeap a | ValidDismantle t rh} @-}
dismantle :: (Ord a) => BinTree a -> ReversedBinomialHeap a
dismantle Empty = RNil
dismantle (Bin m l r h) =
  case r of
    Empty -> RCons (One h (P m h l)) RNil
    Bin _ _ _ hr ->
      let rest = dismantle r
          result = RCons (One h (P m h l)) rest
       in result `withProof` lemma_rlast_preserved (One h (P m h l)) rest
\end{code}

The refinement predicate \texttt{ValidDismantle} ensures structural consistency:
\begin{itemize}
    \item If the tree has non-negative height, the result is non-empty.
    \item The first bit's rank equals the tree's height.
    \item The last bit's rank equals 0 (ensuring compatibility with \texttt{reverseToBinomialHeap}).
\end{itemize}

The proof uses \texttt{lemma\_rlast\_preserved}, which establishes that prepending a bit to a
reversed heap preserves the property that the last bit has rank 0. This lemma is proven by
structural induction on the reversed heap.

\subsubsection{Reversing to Standard Form}

The \texttt{reverseToBinomialHeap} function converts a reversed bit-list back to a standard
binomial heap using an accumulator pattern:

\begin{code}
{-@ reverseToBinomialHeap ::
      rh:{ReversedBinomialHeap a | ReversedEndsAtZero rh} ->
      {h:BinomialHeap a | ValidReversed rh h}
      / [rlen rh] @-}
reverseToBinomialHeap :: ReversedBinomialHeap a -> BinomialHeap a
reverseToBinomialHeap RNil = Nil
reverseToBinomialHeap rh@(RCons b bs) =
  case bs of
    RNil -> Cons b Nil
    RCons _ _ -> reverseAcc bs (Cons b Nil)
                   `withProof` lemma_rlast_tail rh
\end{code}

The precondition \texttt{ReversedEndsAtZero} requires that the last bit has rank 0, ensuring the
resulting heap starts at rank 0 (as required by \texttt{ValidReversed}). The termination metric
\texttt{/ [rlen rh]} proves the function terminates by consuming the reversed list.

\subsection{The \texttt{splitMin} Operation}
\label{sec:binomial-splitmin}

The \texttt{splitMin} operation combines all the previously discussed components to extract the
minimum element and its remaining heap:

\begin{code}
{-@ splitMin ::
      h:{BinomialHeap a | bRank h == 0} ->
      MinView BinomialHeap a @-}
splitMin :: (Ord a) => BinomialHeap a -> MinView BinomialHeap a
splitMin heap =
  if hasOnlyZeros heap
    then EmptyView
    else case extractMin heap of
      (minPennant, restHeap) ->
        let converted = case minPennant of
              P _ 0 _ -> restHeap
              P _ _ _ -> case restHeap of
                Nil -> reverseToBinomialHeap (dismantle (bin minPennant))
                Cons _ _ -> bAdd restHeap
                             (reverseToBinomialHeap (dismantle (bin minPennant)))
         in Min (root minPennant) converted
\end{code}

The operation proceeds as follows:
\begin{enumerate}
    \item Check if the heap is empty (only zeros). If so, return \texttt{EmptyView}.
    \item Extract the minimum pennant and the remaining heap using \texttt{extractMin}.
    \item If the pennant has height 0 (singleton), return it with the remaining heap.
    \item Otherwise, dismantle the pennant's internal tree, reverse it to standard form, and merge
          it with the remaining heap using \texttt{bAdd}.
\end{enumerate}

The refined return type \texttt{MinView BinomialHeap a} is defined in the shared infrastructure
(\S\ref{sec:shared-infra}). The precondition \texttt{bRank h == 0} ensures the input heap starts
at rank 0, which is maintained throughout by \texttt{extractMin},\\ \texttt{reverseToBinomialHeap},
and \texttt{bAdd}.

\subsection{Priority Queue Operations}
\label{sec:binomial-pq-ops}

The priority queue interface operations are implemented using the verified core operations,
with additional rank-normalization through the \texttt{padWithZeros} helper:

\begin{code}
{-@ heapEmpty :: {h:BinomialHeap a | bRank h == 0} @-}
heapEmpty :: BinomialHeap a
heapEmpty = Nil

{-@ heapInsert :: Ord a =>
      a -> h:BinomialHeap a ->
      {h':BinomialHeap a | bRank h' == 0} @-}
heapInsert :: (Ord a) => a -> BinomialHeap a -> BinomialHeap a
heapInsert x h = bAdd (Cons (One 0 (singleton x)) Nil) (padWithZeros h)

{-@ heapMerge :: Ord a =>
      h1:BinomialHeap a -> h2:BinomialHeap a ->
      {h':BinomialHeap a | bRank h' == 0} @-}
heapMerge :: (Ord a) => BinomialHeap a -> BinomialHeap a -> BinomialHeap a
heapMerge h1 h2 = bAdd (padWithZeros h1) (padWithZeros h2)
\end{code}

The \texttt{padWithZeros} function ensures heaps start at rank 0 by prepending \texttt{Zero} bits
as needed. While marked with \texttt{assume} in the current implementation, its correctness follows
from prepending bits with strictly increasing ranks starting from 0.

The \texttt{findMin} operation uses \texttt{minRootInHeap} when the heap is non-empty:

\begin{code}
safeFindMin :: (Ord a) => BinomialHeap a -> Maybe a
safeFindMin h
  | hasOnlyZeros h = Nothing
  | otherwise = Just (minRootInHeap h)
\end{code}

This implementation pattern---checking \texttt{hasOnlyZeros} to enable calling
\texttt{minRootInHeap}---is typical in the verification, where predicates in guards establish
preconditions for subsequent operations.

\section{Summary}
\label{sec:verification-summary}

This chapter demonstrated the verification of two priority queue implementations in LiquidHaskell,
each presenting distinct challenges and verification techniques.

For \textbf{leftist heaps} (\S\ref{sec:verify-leftist}), we achieved complete verification of all
priority queue operations. The verification relies on refined data types that directly encode the
heap property, leftist property, and rank correctness. The key challenge was proving that merge
operations preserve these invariants, which required explicit lemmas for transitivity of lower bounds
and bag equality preservation. The relatively simple structure of leftist heaps allowed for
straightforward induction over the recursive tree structure.

For \textbf{binomial heaps} (\S\ref{sec:verify-binomial}), we verified a more complex compositional
structure consisting of three layers: perfect binary trees with left-ordering, pennants with minimum
roots, and bit-lists representing the heap. Each layer required distinct refinements:
\begin{itemize}
    \item The \texttt{BinTree} layer enforces left-ordering and perfect balance through height constraints.
    \item The \texttt{Pennant} layer ensures the minimum property by relating the root to the internal tree.
    \item The \texttt{BinomialHeap} layer maintains rank consistency across the bit-list structure.
    \item The \texttt{ReversedBinomialHeap} auxiliary structure enables efficient tree-to-heap conversion.
\end{itemize}

The binomial heap verification required careful tracking of ranks through bit-level arithmetic
(\S\ref{sec:binomial-bits}), management of multiple heap representations (standard and reversed,
\S\ref{sec:binomial-dismantle}), and coordination of multiple operations to implement \texttt{splitMin}
(\S\ref{sec:binomial-splitmin}). The \texttt{dismantle} and \texttt{reverseToBinomialHeap} operations
exemplify the compositional verification approach, where structural properties are maintained through
lemmas about auxiliary functions (\texttt{lemma\_rlast\_preserved}, \texttt{lemma\_rlast\_tail}).

Both developments leverage the shared logical infrastructure (\S\ref{sec:shared-infra}), particularly
the \texttt{isLowerBound} predicate and the LiquidHaskell features introduced in Chapter~\ref{ch:lh}:
measures, reflection, PLE, and termination metrics. The systematic use of refined data types ensures
that structural invariants are maintained by construction, with the type system preventing the creation
of invalid heap structures.

The contrast between the two implementations illustrates important principles in verified functional
programming: leftist heaps trade structural complexity for simpler verification, while binomial heaps
achieve better theoretical worst-case complexity bounds at the cost of more intricate verification
involving multiple data structures and auxiliary operations. Both approaches successfully use
LiquidHaskell's refinement type system to achieve machine-checked correctness proofs that closely
mirror the informal reasoning about these classic data structures from Chapter~\ref{ch:impl}.


