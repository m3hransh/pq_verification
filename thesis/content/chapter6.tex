\chapter{Conclusion}
\label{chap:conclusion}

This thesis explored the verification of functional priority queue implementations in Haskell using \textsc{LiquidHaskell}, a lightweight refinement type system that integrates formal reasoning directly into the Haskell ecosystem. Our focus was on verifying essential invariants and correctness properties of two heap variants: the \emph{Leftist Heap} and the \emph{Binomial Heap}. 

\section{Summary of Contributions}
\label{sec:contrib}

We presented verified implementations of key priority queue operations within LiquidHaskell, progressively building from foundational proofs over simple structures to full heap operations.  
Our main contributions can be summarized as follows:

\begin{itemize}
  \item We demonstrated how algebraic data types such as \texttt{BinTree} and \texttt{LeftistHeap} can be extended with refinement types to encode structural invariants, such as the heap-order property and rank relations.
  \item We verified fundamental heap operations---including \texttt{merge}, \texttt{insert}, and \texttt{splitMin}---for the leftist heap, ensuring preservation of heap order and rank properties under recursive definitions.
  \item We extended the framework to the binomial heap, focusing on mechanized proofs for the \texttt{Pennant} structure, the \texttt{merge} (link) function, and the rank-preserving bit-level addition (\texttt{bSum}, \texttt{bCarry}, \texttt{addWithCarry}).
  \item We integrated these verifications with the LiquidHaskell toolchain, showing how reflection, measures, and termination metrics can encode reasoning directly at the type level.
\end{itemize}

Together, these results demonstrate that non-trivial, purely functional data structures can be reasoned about in a practical way without leaving the Haskell ecosystem.

\section{Lessons Learned and Observations}
\label{sec:lessons}

Through the verification process, several technical and conceptual insights emerged about LiquidHaskell’s capabilities and limitations.

\subsection{Strengths of LiquidHaskell}

\paragraph{Lightweight integration.}
LiquidHaskell is comparatively lightweight compared to proof assistants such as Agda or Coq. It allows reasoning directly over existing Haskell code, without the need to re-model the entire language or data structure within a new logical environment. This makes it an ideal choice for incremental verification, especially when working with real-world Haskell libraries.

\paragraph{Expressiveness through refinements.}
By attaching logical predicates directly to types, we can express invariants such as heap order, height relations, or non-emptiness in a concise and composable way. This leads to code that remains executable Haskell, while also serving as a formal specification.

\paragraph{Automation via PLE and SMT solving.}
The combination of \textit{Proof by Logical Evaluation (PLE)} and SMT-based refinement checking often enables LiquidHaskell to automatically discharge many proof obligations, making routine verification nearly effortless once the correct refinements are in place.

\subsection{Limitations and Practical Challenges}

Despite its elegance, the verification process also revealed several limitations that made large-scale verification challenging:

\paragraph{Reflection and reuse.}
LiquidHaskell’s reflection mechanism is both powerful and restrictive. Any function that is used within a reflected definition must itself be reflected, which prevents direct reuse of many Haskell standard-library functions that are not reflected into the refinement logic. This recursive dependency forces the user to re-implement or re-reflect auxiliary functions, leading to significant boilerplate and occasional code duplication.

\paragraph{Limited type-class support.}
Although type classes are a fundamental abstraction in Haskell, their interaction with LiquidHaskell’s refinement logic remains fragile. In principle, one could encode general invariants for a class of data structures (e.g., a \texttt{VerifiedHeap} type class), but in practice the refinement checker struggles to generalize constraints and resolve overloaded instances. Consequently, many proofs must be carried out on a per-function basis, reducing modularity and reuse.

\paragraph{Error reporting and debugging.}
Error messages in LiquidHaskell can be difficult to interpret. Because LiquidHaskell translates annotated Haskell code into GHC Core and then re-interprets it in the SMT-based refinement logic, the resulting errors often refer to internal Core identifiers rather than the original Haskell source. This two-layer translation complicates the debugging process and makes it hard to locate the precise cause of a failed proof.

\paragraph{The ``butterfly effect'' of verification.}
Another practical issue is the high interdependence of reflected functions. Small logical inconsistencies or subtle changes in one definition can propagate widely, causing unrelated proofs to fail elsewhere. This “butterfly effect” makes large proof developments fragile and demands a disciplined structure of modular proofs and minimal reflection scopes.

\paragraph{Limited higher-order reasoning.}
LiquidHaskell’s logic is essentially first-order, and while it supports function values at the Haskell level, reasoning about higher-order properties (e.g., monotonicity of a function parameter) is not straightforward. This limits the expressiveness for verifying generic combinators or polymorphic invariants.

\section{Future Directions}
\label{sec:future}

There are several promising directions to extend this work:

\begin{itemize}
  \item \textbf{Improved abstraction mechanisms.} A richer integration of type classes or modular refinement signatures could improve code reuse across verified data structures.
  \item \textbf{Interoperability with other provers.} Linking LiquidHaskell with external proof assistants (e.g., exporting obligations to Coq or Lean) could allow deeper reasoning when needed, while keeping most proofs lightweight.
  \item \textbf{Enhanced error reporting and tooling.} Improvements to LiquidHaskell’s diagnostic layer—mapping errors more directly to source expressions—would greatly improve usability for larger projects.
  \item \textbf{Extending verification coverage.} Future work could complete the verification of \texttt{findMin} and \texttt{splitMin} for the binomial heap, and explore more advanced invariants such as amortized cost properties or verified performance bounds.
\end{itemize}

\section{Concluding Remarks}
\label{sec:closing}

This thesis showed that LiquidHaskell offers a compelling compromise between expressiveness and practicality: it enables formal verification \emph{within} the host programming language, avoiding the steep learning curve and re-implementation overhead of traditional proof assistants. While the current ecosystem exhibits technical limitations—especially around reflection, type-class abstraction, and error feedback—its lightweight nature makes it uniquely suited for embedding correctness reasoning into everyday functional programming practice.

Ultimately, the experience gained from verifying priority queues demonstrates that refinement types can bridge the gap between formal methods and real software engineering, turning correctness from a post-hoc assurance into a first-class component of functional design.

