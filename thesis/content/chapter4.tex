\chapter { LiquidHaskell Overview }
\texttt{LiquidHaskell} is a static verification tool that extends Haskell with
\emph{refinement types}. In essence, it augments Haskell’s type system with
logical predicates that are automatically checked by an SMT (Satisfiability
Modulo Theories) solver \cite{vazou2014}. This combination makes it possible
to verify properties of Haskell programs in a lightweight and automated way.

\texttt{LiquidHaskell} is implemented as a GHC plugin and works directly on standard
Haskell code. Programmers can enrich type signatures with logical refinements,
such as bounds on integers, shape properties of data structures, or functional
invariants. During compilation, \texttt{LiquidHaskell} generates \emph{subtyping
	queries} from these annotations and delegates them to an SMT solver. If the
queries are valid, the program is accepted as verified; otherwise, Liquid
Haskell produces verification errors.

Compared to traditional interactive theorem provers, \texttt{LiquidHaskell} emphasizes
automation and minimal annotation overhead. Its design philosophy is to
preserve Haskell’s expressiveness while enabling program verification as a
natural extension of the type system. This makes it particularly suitable for
verifying properties of functional data structures, where invariants such as
ordering, balance, or size constraints can be expressed concisely at the type
level.

In the remainder of this chapter, we present the specification language of
\texttt{LiquidHaskell} (Section~\ref{sec:specification}), and discuss its strengths, limitations,
and relation to other verification frameworks.


\section{Type Refinement}
\label{sec:specification}

Refinement types extend conventional type systems by attaching logical predicates
to base types. This enables more precise specifications and allows certain classes
of errors to be detected statically at compile time \cite{vazou2014}.

Consider the following function:

\begin{code}
	lookup :: Int -> [Int] -> Int
	lookup 0 (x : _) = x
	lookup x (_ : xs) = lookup (x - 1) (xs)
\end{code}

The Haskell type system ensures that \texttt{lookup} takes an integers, a list of intergers and
returns an integer. For example, an application \texttt{lookup True [3]} is rejected
because the first argument has type \texttt{Bool}. However, the standard type
system does not rule out the erroneous call \texttt{lookup -1 [3]}.

Of course, we could use Haskell's \texttt{Maybe} type to indicate that the function
returns \texttt{Nothing} for out-of-bounds indices. However, this merely shifts the
handling of invalid inputs to the caller, who must remember to check for the \texttt{Nothing}.


With refinement types, we can express stronger specifications. In
\texttt{LiquidHaskell}, refinements are written inside comments marked by
\texttt{-@} and \texttt{@-}. For instance, we can define non-negative integers as:

\begin{code}
	{-@ x :: {v:Int | v >= 0} @-}
	x :: Int
	x = 2
\end{code}

A refinement type has the general form
\[
	\{\, v:T \mid e \,\},
\]
where \(T\) is a Haskell type and \(e\) is a logical predicate over the
distinguished value variable \(v\). The type denotes the set of all values
\(v:T\) for which \(e\) holds \cite{vazou2014}.

For example, the type \(\{ v:\mathrm{Int} \mid v \geq 0 \}\) describes all
non-negative integers.
For brevity, one can use type aliases or predicates to define commonly used refinements or predicates:

\begin{code}
	predicate Btwn Lo N Hi = Lo <= N && N < Hi
	type Nat =  {v:Int | v >= 0}
\end{code}
Additionally, Holes can be used for Haskell types, as those types can be infereded from the
regualar Haskell type signature or via GHC's type inference \cite{vazou_liquidhaskell_2014}.

In \texttt{LiquidHaskell}, Constants such as integers and booleans are given
singleton types, i.e., types that describe precisely one value
\cite{niki_lecture_2024}. The typing rule for integer literals is:

\[
	\frac{}{ \Gamma \vdash i : \{\,v:\mathrm{Int} \mid v = i \,\} }
	\quad (\mathit{T\text{-}Int})
\]

Here, the environment \(\Gamma\) contains bindings of program variables to
their refinement types.
One important aspect of refinement types is that expressions can be assigned
to multiple types. For instance, the integer literal \(3\) has type \(\{ v:\mathrm{Int} \mid v = 3 \}\), but also
any supertype, such as \(\{ v:\mathrm{Int} \mid v \geq 0 \}\).
Crucially, refinement type systems support
\emph{subtyping}: if \(\tau_1\) is a subtype of \(\tau_2\), then any expression
of type \(\tau_1\) may safely be used where \(\tau_2\) is expected:

\[
	\frac{ \Gamma \vdash e : \tau_1 \quad \Gamma \vdash \tau_1 \preceq \tau_2 }
	{ \Gamma \vdash e : \tau_2 }
	\quad (\mathit{SUBTYPE})
\]

As an illustration, consider the invalid binding:

\begin{code}
	{-@ x :: Nat @-}
	x = -1
\end{code}

By rule \(\mathit{T\text{-}Int}\), the literal \(-1\) has type
\(\{ v:\mathrm{Int} \mid v = -1 \}\). To assign it to \texttt{x} of type \texttt{Nat}, the
checker must show:
\[
	\emptyset \;\vdash\; \{ v:\mathrm{Int} \mid v = -1 \} \;\preceq\;
	\{ v:\mathrm{Int} \mid v \geq 0 \}.
\]
This so called \emph{subtyping query} is then translated into a logical implication, known
as a \emph{verification condition (VC)}:
\[
	(v = -1) \;\Rightarrow\; (v \geq 0).
\]
These logical formula then passed to an SMT solver for validation.
Since the formula is unsatisfiable, the assignment is rejected.

Figure~\ref{fig:notation} summarizes the notation used to translate subtyping
queries into VCs \cite{vazou2014}.
\begin{figure}[htbp]
	\centering
	\renewcommand{\arraystretch}{1.4}
	\begin{tabular}{@{}ll@{}}
		\( (|\Gamma \vdash b_1 \preceq b_2|) \) & \( \doteq (|\Gamma|) \Rightarrow (|b_1|) \Rightarrow (|b_2|) \) \\[1ex]
		\( (|\{x:\mathrm{Int} \mid r\}|) \)     & \( \doteq r \)                                                  \\[1ex]
		\( (|x:\{v:\mathrm{Int} \mid r\}|) \)   & \( \doteq \text{``x is a value''} \Rightarrow r[x/v] \)         \\[1ex]
		\( (|x:(y:\tau_y \to \tau)|) \)         & \( \doteq \text{true} \)                                        \\[1ex]
		\( (|x_1:\tau_1,\ldots,x_n:\tau_n|) \)  & \( \doteq (|x_1:\tau_1|) \land \cdots \land (|x_n:\tau_n|) \)
	\end{tabular}
	\caption{Notation: Translation to VCs \cite{vazou2014}}
	\label{fig:notation}
\end{figure}
\subsection{Function Contracts}
Refinements can also be used to specify function contracts, i.e., pre- and
postconditions. For lookup, we can require that the index is non-negative and
less than the length of the list:

\begin{code}
	lookup :: i : Nat -> xs : {[a] | i < len xs} -> a
\end{code}

The type of second argument states that the list \texttt{xs} must have length greater than \texttt{i}.
\texttt{len} is a function defined by \texttt{LiquidHaskell} in the refinement logic that returns the length of the list.
In Section \ref{sec:reflection}, we will show how to define and use user-defined functions in the refinement logic.

\subsection{Refined Data Types}
In the previous examples, we saw how refinements of input and output of function allow us to have stronger arguments about our program.
We can take this further by refining the data types.
We use the following example as an illustration, following~\cite{jhala2020}:
\begin{code}
	data Slist a = Slist {
	size :: Nat,
	elems :: {v:[a] | len v == size}
	}
\end{code}

This refined \textit{Slist} data type ensures the stored `size` always matches the length of the `elems` list,
as formalized in the refinement annotation.
This ensures that the size of the list is always correct.

In the following section, we show how can we use reflection or measure directives to reason about user-defined Haskell function in the refinement logic.

\subsection{Lifting Functions to the Refinement Logic}
\label{sec:reflection}
When our programs become more complex, we need to define our own functions in the refinement logic and reason about
a function within another function. Refinement Reflection allows deep specification and verification by
reflecting the code implementing a Haskell function into the function’s output refinement type \cite{vazou2018}.
That means we are able to reason about the function's behavior directly in the refinement logic.
There are two ways to do this: \texttt{reflection} and \texttt{measure}.

\texttt{Measure} can be used on a function with one argument which is a Algebraic Data Type (ADT), like a list \cite{niki_lecture_2024}.
Consider the data type of a bag (multiset) defined as a map from elements to their multiplicities:
\begin{code}
	data Bag a = Bag { toMap :: M.Map a Int } deriving Eq
\end{code}

Now we can define a measure \texttt{bag} that computes the bag of elements for a list:
\begin{code}
	{-@ measure bag @-}
	{-@ bag :: Ord a => [a]-> Bag a @-}
	bag :: (Ord a) => [a] -> Bag a
	bag [] = B.empty
	bag (x : xs) = B.put x (bag xs)
\end{code}

\texttt{LiquidHaskell} lifts the Haskell function to the refinement logic, by refining the types of the data constructors with the
definition of the function\cite{niki_lecture_2024}.
For example, \texttt{bag} measure definition refines the type of the \texttt{List}'s constructor to be:
\begin{code}
	Nil  :: {v:List a | bag v = B.empty}
	Cons :: x:a -> l:List a -> {v:List a | bag v = B.put x (bag l)}
\end{code}

Thus, we can use the \texttt{bag} function in the refinement logic to reason about
invariants of the \texttt{List} data type. For instance, in the following example:
\begin{code}
	{-@ equalBagExample1 :: { bag(Cons 1 (Cons 3 Nil)) ==  bag( Cons 2 Nil) } @-}

	>>    VV : {v : () | v == GHC.Tuple.Prim.()}
	>>    .
	>>    is not a subtype of the required type
	>>      VV : {VV##2465 : () | bag (Cons 1 (Cons 3 Nil)) == bag (Cons 2 Nil)}
\end{code}

The \texttt{\{x = y\}} is shorthand for \texttt{\{v :() | x = y\}}, where $x$ and $y$ are expressions.
This formulation is motivated by the fact that the equality predicate $x = y$ is a condition that does not depend on any particular value.
Note that equality for bags is defined as the equality of the underlying maps that already have a built-in equality function.


Reflection is another useful feature that allows the user to define a function in the refinement logic, providing
the SMT solver with the function's behavior \cite{vazou2018}.
This has the advantage of allowing the user to lift in the logic functions with more than one argument, but the verification
is no more automated \cite{niki_lecture_2024}.
Additionally, with the use of a library of combinators provided by \texttt{LiquidHaskell}, we can leverage
the existing programming constructs (e.g. pattern-matching and recursion) to prove the correctness of the
program and use the principle of programs-as-proofs.
(known as Curry-Howard isomorphism)\cite{vazou2018, wadler_propositions_2015}.

To illustrate the use of reflection, we define the \texttt{(++)} function in the refinement logic as follows:

\begin{code}
	{-@ LIQUID "--reflection" @-}
	{-@ infixr ++ @-}
	{-@ reflect ++ @-}

	{-@ (++) :: xs:[a] -> ys:[a] -> { zs:[a] | len zs == len xs + len ys } @-}
	(++) :: [a] -> [a] -> [a]
	[] ++ ys = ys
	(x : xs) ++ ys = x : (xs ++ ys)
\end{code}
The \texttt{\{-@ LIQUID "--reflection" @-\}} annotation used to activate the reflection feature in \texttt{LiquidHaskell}.
The \texttt{reflect} annotation, lift the \texttt{(++)} into the logic in three steps \cite{vazou2018}:
\begin{enumerate}
	\item \textbf{Definition}: The annotation creates an \textit{uninterpreted function} \texttt{
	      (++) :: [a] -> [a] -> [a]} in the refinement logic. By uninterpreted, we mean that the logical \texttt{(++)} is
	      not connected to the program function \texttt{(++)}; in the logic, \texttt{(++)} only satisfies the \textit{congruence axiom}.
	\item \textbf{Reflection}: In this step, \texttt{LiquidHaskell} reflects the definition of \texttt{(++)} into its refinement type
	      by automatically strengthening the defined function type for \texttt{(++)} to:


\begin{code}
  (++) :: xs:[a] -> ys:[a]
  -> { zs:[a] | len zs == len xs + len ys
  && zs = xs ++ ys
  && ppProp xs ys }
\end{code}
	      where \texttt{ppProp} is an alias for the following refinement, derived from the function's definition:
\begin{code}
  ppProp xs ys = if xs == [] then ys
  else cons (head xs) (ppProp (tail xs) ys)

\end{code}
	\item \textbf{Application}: With the reflected refinement type, each application of \texttt{(++)}
	      in the code automatically unfolds the definition of \texttt{(++)} only \textit{once} in the logic. In the
	      next section, we will look into \texttt{PLE} that allows to unfold the definition of the function multiple times.
\end{enumerate}
we can now reason about properties of \texttt{(++)} in the refinement logic that requires unfolding its definition,
as opposed to treating it only as an uninterpreted function.
In the following subsection,
we will show how to use \texttt{LiquidHaskell} to verify that the \texttt{(++)} function is associative.

\subsection{Refinement Abstraction}
In addition to reflection and measures, \texttt{LiquidHaskell} provides powerful abstraction mechanisms for refinement types.
Suppose we want to define a list where elements satisfy a relation with their neighbors.
We can use \texttt{Refinement Abstraction} to define a new data type that abstracts over the refinement predicate \cite{vazou_liquidhaskell_2014}:

\begin{code}
	data PList a <p :: a -> a -> Bool> =
	Nil
	| Cons { phd :: a, ptl :: PList <p> a <p phd> }
\end{code}

Here, the type \texttt{a<p>} is a refinement type, equivalent to \texttt{\{v:a | p\ v\}} .
The abstraction \texttt{<p :: a -> a -> Bool>} allows us to parameterize the list by a binary predicate \texttt{p}.

We can now use this abstraction to define a list of integers where each element is less than or equal to the next:

\begin{code}
	type SortedList = PList <{\x y -> x <= y}> Int
\end{code}

LiquidHaskell can verify that the following list is sorted:

\begin{code}
	{-@ ok :: SortedList @-}
	ok :: PList Int
	ok = Cons 1 (Cons 2 (Cons 3 Nil))
\end{code}

\input{figures/plist.tex}
% The abstraction allows us to define other properties as well, such as strictly increasing lists, by changing the predicate.
\subsection{Equational Proofs}
\texttt{LiquidHaskell} allows formulation of proofs following the style of calculational or equational reasoning popularized in classic texts
and implemented in proof assistants like Coq and Agda \cite{vazou2018}.
It comes with the proof combinators library that allows to make the proofs more readable.

\paragraph{Proof Type.}
\begin{code}[label={lst:proof-type}]
	type Proof = ()
\end{code}
The alias \texttt{Proof} is defined as the unit type \texttt{()}, representing the result of a completed proof.

\paragraph{Equality Combinator.}
\begin{code}[label={lst:proof-eq}]
	{-@ (===) :: x:a -> y:{a | y == x} -> {v:a | v == x && v == y} @-}
	(===) :: a -> a -> a
	_ === y = y
\end{code}
The \texttt{(===)} function proves equality. It takes \texttt{x:a} and \texttt{y:\{a | y == x\}}, returning a value refined as \texttt{\{v:a | v == x \&\& v == y\}}.

\paragraph{QED Marker.}
\begin{code}[label={lst:proof-qed}]
	data QED = QED

	(***) :: a -> QED -> Proof
	_ *** _ = ()
\end{code}
The \texttt{QED} data type is used to signal the end of a proof. The \texttt{(***)} operator takes a value and a \texttt{QED}, returning \texttt{Proof} (i.e., \texttt{()}).

\paragraph{Question-Mark Combinator.}
\begin{code}[label={lst:proof-question}]
	{-@ (?) :: forall a b <pa :: a -> Bool, pb :: b -> Bool>. a<pa> -> b<pb> -> a<pa> @-}
	(?) :: a -> b -> a
	x ? _ = x
\end{code}
The \texttt{(?)} combinator preserves refinements. With type \texttt{a<pa> -> b<pb> -> a<pa>}, it maintains the refinement \texttt{pa} of the first argument, allowing properties to be carried across proof steps.

\paragraph{WithProof Combinator.}
\begin{code}[label={lst:proof-withproof}]
	{-@ withProof :: x:a -> b -> {v:a | v = x} @-}
	{-@ define withProof x y = (x) @-}
	withProof :: a -> b -> a
	withProof x _ = x
\end{code}
The \texttt{withProof} combinator enforces equality between input and output.
With type \texttt{x:a -> b -> \{v:a | v = x\}}, it asserts that the returned value is exactly \texttt{x}, making it useful for chaining with \texttt{(===)} in equational reasoning.

In the following example, we show how to use these combinators to verify that the \texttt{(++)} function is associative:


\begin{code}[label=lst:associative]
	{-@ assoc :: xs:[a] -> ys:[a] -> zs:[a]
	-> { (xs ++ ys) ++ zs = xs ++ (ys ++ zs) } @-}
	assoc :: [a] -> [a] -> [a] -> ()
	assoc [] ys zs = ([] ++ ys) ++ zs
	=== ys ++ zs
	=== [] ++ (ys ++ zs)
	*** QED

	assoc (x : xs) ys zs = ((x : xs) ++ ys) ++ zs
	===  x : (xs ++ ys) ++ zs
	=== x : ((xs ++ ys) ++ zs) ? assoc xs ys zs
	=== (x : xs) ++ (ys ++ zs)
	*** QED
\end{code}
\vspace{1em}

As you can see, we use proof by induction and in the induction step we use recursive call in the last step.

\subsection{Totality}
Ensuring \emph{total} functions—functions defined for all possible inputs—is essential in program verification.
In Haskell, however, many heap operations are naturally partial.
Consider the definition of \texttt{findMin} for leftist heaps:

\begin{code}
	findMin :: Heap a -> a
	findMin (Node x _ _) = x
\end{code}

This works for non-empty heaps but fails on \texttt{Empty}, resulting in a runtime exception.
In GHC’s Core, the missing case is made explicit through a call to \texttt{patError}:

\begin{code}
	findMin d = case d of
	Node x _ _ -> x
	Empty -> patError "findMin"
\end{code}

Here, \texttt{patError} is technically total, but it has an uninhabited type:

\begin{code}
	patError :: {v:String | false} -> a
\end{code}

\texttt{LiquidHaskell} eliminates such dead code by requiring refinements that ensure \texttt{findMin} is only applied to non-empty heaps.
This can be achieved by defining a measure and a corresponding predicate:

\begin{code}
	measure isNonEmpty :: Heap a -> Prop
	isNonEmpty (Node _ _ _) = true
	isNonEmpty Empty = false

	predicate NonEmp H = isNonEmpty H
\end{code}

Using this predicate, we refine the type of \texttt{findMin}:

\begin{code}
	findMin :: {h:Heap a | NonEmp h} -> a
\end{code}

Now \texttt{LiquidHaskell} verifies that the \texttt{Empty} branch is unreachable.
When pattern matching on \texttt{d = Empty}, the environment is refined to:

\begin{code}
	Empty :: {v:Heap a | NonEmp v && v = Empty}
\end{code}

This condition is contradictory: \texttt{v = Empty} implies the heap is empty, while \texttt{NonEmp v} requires it to be non-empty.
Since no such value exists, \texttt{LiquidHaskell} concludes that the call to \texttt{patError} is infeasible.
Thus, \texttt{findMin} is total under its precondition.
The burden shifts to clients: they must prove statically that any heap passed to \texttt{findMin} is non-empty.

The same reasoning applies to \texttt{deleteMin}, which is unsafe on empty heaps.
By refining its type, we likewise guarantee totality:

\begin{code}
	deleteMin :: {h:Heap a | NonEmp h} -> Heap a
\end{code}

\subsection{Termination}
Another crucial aspect of \texttt{LiquidHaskell} is termination checking.
Ensuring that all functions terminate is necessary for the soundness of the refinement type system, since non-termination can undermine logical consistency \cite{niki_lecture_2024}.
\texttt{LiquidHaskell} enforces this by associating a well-founded termination metric with a function’s parameters and proving—via refinement checking—that the metric decreases with each recursive call \cite{vazou_liquidhaskell_2014}.

For example, consider the factorial function:

\begin{code}
	fac :: n:Nat -> Nat / [n]
\end{code}

The termination metric \texttt{[n]} specifies that \texttt{n} must decrease in each recursive call.

Metrics need not be limited to single arguments.
For instance, the \texttt{range} function uses an expression as the metric:

\begin{code}
	{-@ range :: lo:Int -> hi:Int -> [Int] / [hi - lo] @-}
	range :: Int -> Int -> [Int]
	range lo hi
	| lo < hi = lo : range (lo + 1) hi
	| otherwise = []
\end{code}

Although neither \texttt{lo} nor \texttt{hi} decreases alone, their difference \texttt{hi - lo} does.

Some functions require more general metrics.
When multiple arguments may decrease, lexicographic ordering is used.
Consider the greatest common divisor (GCD):

\begin{code}
	gcd :: Int -> Int -> Int
	gcd 0 b = 0
	gcd a 0 = a
	gcd a b | a == b = a
	| a > b = gcd (a - b) b
	| a < b = gcd a (b - a)
\end{code}

Its refined type uses lexicographic ordering:

\begin{code}
	gcd :: a:Nat -> b:Nat -> Nat / [a, b]
\end{code}

The same technique applies to mutually recursive functions such as \texttt{isEven} and \texttt{isOdd} \cite{vazou_liquidhaskell_2014}:

\begin{code}
	isEven 0 = True
	isEven n = isOdd (n - 1)

	isOdd n = not (isEven n)
\end{code}

Here, \texttt{isEven} decreases on its argument, while \texttt{isOdd} does not.
By specifying metrics as:

\begin{code}
	isEven :: n:Nat -> Bool / [n, 0]
	isOdd :: n:Nat -> Bool / [n, 1]
\end{code}

\texttt{LiquidHaskell} checks that each recursive call reduces the lexicographic metric: e.g., \texttt{[n, 0]} is greater than \texttt{[n-1, 1]} in the call from \texttt{isEven} to \texttt{isOdd}.

Termination checking also extends to finite data structures by using their size.
For example, the \texttt{bag} function can be checked using list length:

\begin{code}
	bag :: Ord a => xs:[a] -> Bag a / [len xs]
\end{code}

In practice, \texttt{LiquidHaskell} assumes by default that the first argument with a size measure (e.g., \texttt{len} for lists) decreases \cite{vazou_liquidhaskell_2014}.

In some cases, Haskell functions are deliberately non-terminating.
For such functions, termination checking can be disabled locally with the \texttt{lazy} annotation, or globally with the directive:

\begin{code}
	{-@ LIQUID "--no-termination" @-}
\end{code}

\subsection{Proof by Logical Evaluation}
In our proof in code \ref{lst:associative}, we primarily relied on straightforward unfoldings of the \texttt{(++)} function definition.
However, \texttt{LiquidHaskell} provides a directive known as \texttt{Proof by Logical Evaluation} (PLE), which offers two significant advantages \cite{vazou2018}.
First, PLE is guaranteed to construct an equational proof whenever one can be derived solely from unfoldings of function definitions, provided the user supplies necessary lemmas and induction hypotheses \cite{vazou2018}.
Second, under practical conditions that are commonly satisfied, PLE is guaranteed to terminate \cite{vazou2018}.
We can activate PLE by adding \texttt{\{-@ LIQUID "---ple" @-\}} annotation to automate the most parts of the proof for associativity of \texttt{(++)}:

\begin{code}
	{-@ LIQUID "--ple" @-}
	{-@ assoc :: xs:[a] -> ys:[a] -> zs:[a]
	-> { (xs ++ ys) ++ zs = xs ++ (ys ++ zs) } @-}
	assoc :: [a] -> [a] -> [a] -> ()
	assoc [] ys zs = ()
	assoc (x : xs) ys zs = assoc xs ys zs
\end{code}

In the above code, we only need to provide the base case and induction hypotheses, and
\texttt{LiquidHaskell} will automatically unfold the definition of \texttt{(++)} to prove the associativity of the function.
In the following chapter, we learn how to use \texttt{LiquidHaskell} to verify properties of functional data structures.
