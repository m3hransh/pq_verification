\chapter { \texttt{LiquidHaskell} Overview }
\texttt{LiquidHaskell} is a static verification tool that extends Haskell with
\emph{refinement types}. In essence, it augments Haskell’s type system with
logical predicates that are automatically checked by an SMT (Satisfiability
Modulo Theories) solver \cite{vazou2014}. This combination makes it possible
to verify properties of Haskell programs in a lightweight and automated way.

\texttt{LiquidHaskell} is implemented as a GHC plugin and works directly on standard
Haskell code. Programmers can enrich type signatures with logical refinements,
such as bounds on integers, shape properties of data structures, or functional
invariants. During compilation, \texttt{LiquidHaskell} generates \emph{subtyping
	queries} from these annotations and delegates them to an SMT solver. If the
queries are valid, the program is accepted as verified; otherwise, Liquid
Haskell produces verification errors.

Compared to traditional interactive theorem provers, \texttt{LiquidHaskell} emphasizes
automation and minimal annotation overhead. Its design philosophy is to
preserve Haskell’s expressiveness while enabling program verification as a
natural extension of the type system. This makes it particularly suitable for
verifying properties of functional data structures, where invariants such as
ordering, balance, or size constraints can be expressed concisely at the type
level.

In the remainder of this chapter, we present the specification language of
\texttt{LiquidHaskell} (Section~\ref{sec:specification}), and discuss its strengths, limitations,
and relation to other verification frameworks.


\section{Type Refinement}
\label{sec:specification}

Refinement types extend conventional type systems by attaching logical predicates
to base types. This enables more precise specifications and allows certain classes
of errors to be detected statically at compile time \cite{vazou2014}.

Consider the following function:

\begin{code}
	lookup :: Int -> [Int] -> Int
	lookup 0 (x : _) = x
	lookup x (_ : xs) = lookup (x - 1) (xs)
\end{code}

The Haskell type system ensures that \texttt{lookup} takes an integers, a list of intergers and
returns an integer. For example, an application \texttt{lookup True [3]} is rejected
because the first argument has type \texttt{Bool}. However, the standard type
system does not rule out the erroneous call \texttt{lookup -1 [3]}.

Of course, we could use Haskell's \texttt{Maybe} type to indicate that the function
returns \texttt{Nothing} for out-of-bounds indices. However, this merely shifts the
handling of invalid inputs to the caller, who must remember to check for the \texttt{Nothing}.


With refinement types, we can express stronger specifications. In
\texttt{LiquidHaskell}, refinements are written inside comments marked by
\texttt{-@} and \texttt{@-}. For instance, we can define non-negative integers as:

\begin{code}
	{-@ type Nat = {v:Int | v >= 0} @-}
\end{code}

A refinement type has the general form
\[
	\{\, v:T \mid e \,\},
\]
where \(T\) is a Haskell type and \(e\) is a logical predicate over the
distinguished value variable \(v\). The type denotes the set of all values
\(v:T\) for which \(e\) holds \cite{vazou2014}.

For example, the type \(\{ v:\mathrm{Int} \mid v \geq 0 \}\) describes all
non-negative integers. Constants such as integers and booleans are given
singleton types, i.e., types that describe precisely one value
\cite{niki_lecture_2024}. The typing rule for integer literals is:

\[
	\frac{}{ \Gamma \vdash i : \{\,v:\mathrm{Int} \mid v = i \,\} }
	\quad (\mathit{T\text{-}Int})
\]

Here, the environment \(\Gamma\) contains bindings of program variables to
their refinement types.
One important aspect of refinement types is that expressions can be assigned
to multiple types. For instance, the integer literal \(3\) has type \(\{ v:\mathrm{Int} \mid v = 3 \}\), but also
any supertype, such as \(\{ v:\mathrm{Int} \mid v \geq 0 \}\).
Crucially, refinement type systems support
\emph{subtyping}: if \(\tau_1\) is a subtype of \(\tau_2\), then any expression
of type \(\tau_1\) may safely be used where \(\tau_2\) is expected:

\[
	\frac{ \Gamma \vdash e : \tau_1 \quad \Gamma \vdash \tau_1 \preceq \tau_2 }
	{ \Gamma \vdash e : \tau_2 }
	\quad (\mathit{SUBTYPE})
\]

As an illustration, consider the invalid binding:

\begin{code}
	{-@ x :: Nat @-}
	x = -1
\end{code}

By rule \(\mathit{T\text{-}Int}\), the literal \(-1\) has type
\(\{ v:\mathrm{Int} \mid v = -1 \}\). To assign it to \texttt{x} of type \texttt{Nat}, the
checker must show:
\[
	\emptyset \;\vdash\; \{ v:\mathrm{Int} \mid v = -1 \} \;\preceq\;
	\{ v:\mathrm{Int} \mid v \geq 0 \}.
\]
This so called \emph{subtyping query} is then translated into a logical implication, known
as a \emph{verification condition (VC)}:
\[
	(v = -1) \;\Rightarrow\; (v \geq 0).
\]
These logical formula then passed to an SMT solver for validation.
Since the formula is unsatisfiable, the assignment is rejected.

Figure~\ref{fig:notation} summarizes the notation used to translate subtyping
queries into VCs \cite{vazou2014}.
\begin{figure}[htbp]
	\centering
	\renewcommand{\arraystretch}{1.4}
	\begin{tabular}{@{}ll@{}}
		\( (|\Gamma \vdash b_1 \preceq b_2|) \) & \( \doteq (|\Gamma|) \Rightarrow (|b_1|) \Rightarrow (|b_2|) \) \\[1ex]
		\( (|\{x:\mathrm{Int} \mid r\}|) \)     & \( \doteq r \)                                                  \\[1ex]
		\( (|x:\{v:\mathrm{Int} \mid r\}|) \)   & \( \doteq \text{``x is a value''} \Rightarrow r[x/v] \)         \\[1ex]
		\( (|x:(y:\tau_y \to \tau)|) \)         & \( \doteq \text{true} \)                                        \\[1ex]
		\( (|x_1:\tau_1,\ldots,x_n:\tau_n|) \)  & \( \doteq (|x_1:\tau_1|) \land \cdots \land (|x_n:\tau_n|) \)
	\end{tabular}
	\caption{Notation: Translation to VCs \cite{vazou2014}}
	\label{fig:notation}
\end{figure}
\subsection{Function Contracts}
Refinements can also be used to specify function contracts, i.e., pre- and
postconditions. For lookup, we can require that the index is non-negative and
less than the length of the list:

\begin{code}
	lookup :: i : Nat -> xs : {[a] | i < len xs} -> a
\end{code}

The type of second argument states that the list \texttt{xs} must have length greater than \texttt{i}.
\texttt{len} is a function defined by \texttt{LiquidHaskell} in the refinement logic that returns the length of the list.
In Section \ref{sec:reflection}, we will show how to define and use user-defined functions in the refinement logic.

\subsection{Refined Data Types}
In the previous examples, we saw how refinements of input and output of function allow us to have stronger arguments about our program.
We can take this further by refining the data types.
We use the following example as an illustration, following~\cite{jhala2020}:
\begin{code}
	data Slist a = Slist { size :: Int, elems :: [a] }

	{-@ data Slist a = Slist { size :: Nat, elems :: {v:[a] | len v == size} } @-}
\end{code}

This refined \textit{Slist} data type ensures the stored `size` always matches the length of the `elems` list,
as formalized in the refinement annotation.
This ensures that the size of the list is always correct.

In the following section, we show how can we use reflection or measure directives to reason about user-defined Haskell function in the refinement logic.

\subsection{Lifting Functions to the Refinement Logic}
\label{sec:reflection}
When our programs become more complex, we need to define our own functions in the refinement logic and reason about
a function within another function. Refinement Reflection allows deep specification and verification by
reflecting the code implementing a Haskell function into the function’s output refinement type \cite{vazou2018}.
That means we are able to reason about the function's behavior directly in the refinement logic.
There are two ways to do this: \texttt{reflection} and \texttt{measure}.

\texttt{Measure} can be used on a function with one argument which is a Algebraic Data Type (ADT), like a list \cite{niki_lecture_2024}.
Consider the data type of a bag (multiset) defined as a map from elements to their multiplicities:
\begin{code}
	data Bag a = Bag { toMap :: M.Map a Int } deriving Eq
\end{code}

Now we can define a measure \texttt{bag} that computes the bag of elements in for a list:
\begin{code}

	{-@ measure bag @-}
	{-@ bag :: Ord a => [a]-> Bag a @-}
	bag :: (Ord a) => [a] -> Bag a
	bag [] = B.empty
	bag (x : xs) = B.put x (bag xs)
\end{code}

\texttt{LiquidHaskell} lifts the Haskell function to the refinement logic, by refining the types of the data constructors with the
definition of the function\cite{niki_lecture_2024}.
For example, \texttt{bag} measure definition refines the type of the \texttt{List}'s constructor to be:
\begin{code}
	Nil  :: {v:List a | bag v = B.empty}
	Cons :: x:a -> l:List a -> {v:List a | bag v = B.put x (bag l)}
\end{code}

Thus, we can use the \texttt{bag} function in the refinement logic to reason about
invariants of the \texttt{List} data type. For instance, in the following example:
\begin{code}
	{-@ equalBagExample1 :: { bag(Cons 1 (Cons 3 Nil)) ==  bag( Cons 2 Nil) } @-}

	>>    VV : {v : () | v == GHC.Tuple.Prim.()}
	>>    .
	>>    is not a subtype of the required type
	>>      VV : {VV##2465 : () | bag (Cons 1 (Cons 3 Nil)) == bag (Cons 2 Nil)}
\end{code}

The \texttt{\{x = y\}} is shorthand for \texttt{\{v :() | x = y\}}, where $x$ and $y$ are expressions.
This formulation is motivated by the fact that the equality predicate $x = y$ is a condition that does not depend on any particular value.
Note that equality for bags is defined as the equality of the underlying maps that already have a built-in equality function.


Reflection is another useful feature that allows the user to define a function in the refinement logic, providing
the SMT solver with the function's behavior \cite{vazou2018}.
This has the advantage of allowing the user to lift in the logic functions with more than one argument, but the verification
is no more automated \cite{niki_lecture_2024}.
Additionally, with the use of a library of combinators provided by \texttt{LiquidHaskell}, we can leverage
the existing programming constructs (e.g. pattern-matching and recursion) to prove the correctness of the
program and use the principle of programs-as-proofs.
(known as Curry-Howard isomorphism)\cite{vazou2018, wadler_propositions_2015}.

To illustrate the use of reflection, we define the \texttt{(++)} function in the refinement logic as follows:

\begin{code}
	{-@ LIQUID "--reflection" @-}
	{-@ infixr ++ @-}
	{-@ reflect ++ @-}

	{-@ (++) :: xs:[a] -> ys:[a] -> { zs:[a] | len zs == len xs + len ys } @-}
	(++) :: [a] -> [a] -> [a]
	[] ++ ys = ys
	(x : xs) ++ ys = x : (xs ++ ys)
\end{code}
The \texttt{\{-@ LIQUID "--reflection" @-\}} annotation used to activate the reflection feature in \texttt{LiquidHaskell}.
The \texttt{reflect} annotation, lift the \texttt{(++)} into the logic in three steps \cite{vazou2018}:
\begin{enumerate}
	\item \textbf{Definition}: The annotation creates an \textit{uninterpreted function} \texttt{
	      (++) :: [a] -> [a] -> [a]} in the refinement logic. By uninterpreted, we mean that the logical \texttt{(++)} is
	      not connected to the program function \texttt{(++)}; in the logic, \texttt{(++)} only satisfies the \textit{congruence axiom}.
	\item \textbf{Reflection}: In this step, \texttt{LiquidHaskell} reflects the definition of \texttt{(++)} into its refinement type
	      by automatically strengthening the defined function type for \texttt{(++)} to:


\begin{code}
  (++) :: xs:[a] -> ys:[a] 
      -> { zs:[a] | len zs == len xs + len ys 
          && zs = xs ++ ys
          && ppProp xs ys }
\end{code}
	      where \texttt{ppProp} is an alias for the following refinement, derived from the function's definition:
\begin{code}
  ppProp xs ys = if xs == [] then ys
  else cons (head xs) (ppProp (tail xs) ys)

\end{code}
	\item \textbf{Application}: With the reflected refinement type, each application of \texttt{(++)}
	      in the code automatically unfolds the definition of \texttt{(++)} only \textit{once} in the logic. In the
	      next section, we will look into \texttt{PLE} that allows to unfold the definition of the function multiple times.
\end{enumerate}
we can now reason about properties of \texttt{(++)} in the refinement logic that requires unfolding its definition,
as opposed to treating it only as an uninterpreted function.
In the following subsection, 
we will show how to use \texttt{LiquidHaskell} to verify that the \texttt{(++)} function is associative.

\subsection{Equational Proofs}
\texttt{LiquidHaskell} allows formulation of proofs following the style of calculational or equational reasoning popularized in classic texts
and implemented in proof assistants like Coq and Agda \cite{vazou2018}.
It comes with the proof combinators library that allows to make the proofs more readable.
For example, it defines the following proof combinators:

\begin{code}[label={lst:proof-combinators}]
  type Proof = ()

  {-@ (===) :: x:a -> y:{a | y == x} -> {v:a | v == x && v == y} @-}
  (===) :: a -> a -> a
  _ === y  = y

  data QED = QED

  (***) :: a -> QED -> Proof
  _***_ = ()

  {-@ (?) :: forall a b <pa :: a -> Bool, pb :: b -> Bool>. a<pa> -> b<pb> -> a<pa> @-}
  (?) :: a -> b -> a
  x ? _ = x

  {-@ withProof :: x:a -> b -> {v:a | v = x} @-}
  {-@ define withProof    x      y            = (x) @-}
  withProof :: a -> b -> a
  withProof x _ = x
\end{code}

\vspace{1em}

\texttt{Proof} is a type alias for the unit type \texttt{()}, representing the result of a completed proof. The \texttt{(***)} function takes a value of type \texttt{a} and a value of type \texttt{QED}, returning \texttt{Proof} (i.e., \texttt{()}), and is used to mark the end of a proof. The \texttt{(===)} function proves equality, taking \texttt{x:a} and \texttt{y:\{a | y == x\}}, returning a value with refinement \texttt{\{v:a | v == x \&\& v == y\}}.

Both \texttt{(?)} and \texttt{withProof} return their first argument, but differ in Liquid Haskell’s equational proofing:
\begin{itemize}
  \item \texttt{(?)}: With type \texttt{a<pa> -> b<pb> -> a<pa>}, it preserves the refinement \texttt{pa} of the input, making it ideal for maintaining properties across proof steps.
  \item \texttt{withProof}: With type \texttt{x:a -> b -> \{v:a | v = x\}}, it asserts output equality to the input (\texttt{v = x}), suited for establishing equalities to chain with \texttt{(===)} in equational reasoning.
\end{itemize}

In the following example, we show how to use these combinators to verify that the \texttt{(++)} function is associative:


\begin{code}[ label={lst:associative}]
{-@ assoc :: xs:[a] -> ys:[a] -> zs:[a] 
  -> { (xs ++ ys) ++ zs = xs ++ (ys ++ zs) } @-}
assoc :: [a] -> [a] -> [a] -> ()
assoc [] ys zs = ([] ++ ys) ++ zs
               === ys ++ zs
               === [] ++ (ys ++ zs)
               *** QED

assoc (x : xs) ys zs = ((x : xs) ++ ys) ++ zs
                     ===  x : (xs ++ ys) ++ zs
                     === x : ((xs ++ ys) ++ zs) ? assoc xs ys zs
                     === (x : xs) ++ (ys ++ zs)
                     *** QED
\end{code}
\vspace{1em}

As you can see, we use proof by induction and in the induction step we use recursive call in the last step.
\section { Strengths and Limitations }
Where it excels and where it struggles (e.g., termination proofs, higher-order functions).
\section { Related Work }
Comparison with Coq, Agda, Dafny, or other tools verifying similar structures.
